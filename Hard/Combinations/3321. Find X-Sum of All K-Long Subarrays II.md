### [Find X-Sum of All K-Long Subarrays II](https://leetcode.com/problems/find-x-sum-of-all-k-long-subarrays-ii/description/) - Notes

You’re given:

* An integer array `nums`
* Two integers `k` (window size) and `x` (number of top frequent elements)

For every subarray of size `k`, we must:

1. Count how many times each number appears.
2. Keep **only** the `x` most frequent elements.

   * If two elements have the same frequency, prefer the **larger** value.
3. Compute the **sum of all occurrences** of these `x` elements.

Return an array `answer` such that `answer[i]` is the x-sum of `nums[i..i+k-1]`.

### **Example**

**Input:**
`nums = [1,1,2,2,3,4,2,3], k = 6, x = 2`

**Output:**
`[6, 10, 12]`

**Explanation:**

* Subarray `[1,1,2,2,3,4]` → keep 1 & 2 → sum = `1+1+2+2 = 6`
* Subarray `[1,2,2,3,4,2]` → keep 2 & 4 → sum = `2+2+2+4 = 10`
* Subarray `[2,2,3,4,2,3]` → keep 2 & 3 → sum = `2+2+2+3+3 = 12`



##  Naive Approach (Brute Force)

For each window:

1. Use a `Counter` to count frequencies.
2. Sort by `(frequency desc, value desc)`.
3. Take the top `x` elements.
4. Sum all occurrences of those elements in the window.

```python []
#Dont copy this one, it will throw TLE, It is just for Understanding
def findXSum(nums, k, x):
    n = len(nums)
    ans = []
    for i in range(n - k + 1):
        window = nums[i:i+k]
        freq = Counter(window)
        top = sorted(freq.items(), key=lambda p: (p[1], p[0]), reverse=True)[:x]
        keep = set(v for v, _ in top)
        ans.append(sum(num for num in window if num in keep))
    return ans
```

### Complexity

* Sorting for every window → `O((n - k + 1) * k log k)`
* Works for small arrays but **too slow** for `n = 10⁵`.

---

##  Optimized Idea 
> ### (Sliding Window + Ordered Structures)

Instead of recomputing from scratch:

* Use a **sliding window** to move one step at a time.
* Maintain:

  * `freq` = frequency of each number in the current window.
  * Two ordered sets:

    * `top`: top `x` most frequent elements.
    * `rest`: the remaining ones.
  * `top_sum`: running sum of all occurrences of elements in `top`.

When the window slides:

* One element goes out, another comes in.
* We update `freq`, and rebalance which elements belong to `top` vs `rest`.
* `top_sum` is adjusted *incrementally*, so we never recompute from scratch.


## Intuition

We always want `top` to contain the `x` elements that are:

* Most frequent, and
* Highest in value when frequencies tie.

We can store tuples `(freq, value)` inside a balanced structure (`SortedList` from `sortedcontainers`), since it automatically keeps order.

By maintaining this invariant as the window slides, we get a **fully dynamic** and **efficient** solution.


```python []
class Solution:
    def findXSum(self, nums, k, x):
        freq = Counter()
        top = SortedList()
        rest = SortedList()
        top_sum = 0
        ans = []

        def balance():# keeps top and rest balanced
            nonlocal top_sum
            while len(top) < x and rest:
                f, v = rest.pop()
                top.add((f, v))
                top_sum += f * v
            while len(top) > x:
                f, v = top.pop(0)
                top_sum -= f * v
                rest.add((f, v))
            while rest and top and rest[-1] > top[0]:
                f1, v1 = rest.pop()
                f2, v2 = top.pop(0)
                top_sum += f1 * v1 - f2 * v2
                top.add((f1, v1))
                rest.add((f2, v2))

        def add(num):
            nonlocal top_sum
            old = (freq[num], num)
            if old in top:
                top.remove(old)
                top_sum -= old[0] * old[1]
            elif old in rest:
                rest.remove(old)
            freq[num] += 1
            new = (freq[num], num)
            rest.add(new)
            balance()

        def remove(num):
            nonlocal top_sum
            old = (freq[num], num)
            if old in top:
                top.remove(old)
                top_sum -= old[0] * old[1]
            else:
                rest.remove(old)
            freq[num] -= 1
            if freq[num] > 0:
                rest.add((freq[num], num))
            else:
                del freq[num]
            balance()

        for i in range(k):# initial window
            add(nums[i])
        ans.append(top_sum)

        for i in range(k, len(nums)):# slide the window
            remove(nums[i - k])
            add(nums[i])
            ans.append(top_sum)

        return ans
```
---

### Time Complexity

* Each add/remove → `O(log n)` due to `SortedList`
* Each balance step keeps total reordering small
   
**Overall**: 
> ## **O(n log n)**

   Handles up to `n = 10⁵` smoothly
### Space Complexity

freq map → stores at most n distinct elements → O(n)

top + rest multisets together store all current window elements (up to k) → O(k), bounded by O(n) in worst case.

>  ### O(n)



### Takeaways

* This problem tests **frequency ranking + sliding window maintenance**.
* Direct sorting kills performance so incremental rebalancing saves time.
* `SortedList` or balanced trees are perfect for maintaining ordered top elements efficiently.

---

