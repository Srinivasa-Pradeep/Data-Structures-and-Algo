### [Maximize the Number of Partitions After Operations](https://leetcode.com/problems/maximize-the-number-of-partitions-after-operations/description/) - Notes

You are given a string `s` and an integer `k`.
You may change **at most one character** in `s` to any lowercase letter.
Then, repeatedly remove the **longest prefix** of `s` that contains **at most `k` distinct characters** until the string is empty.
Return the **maximum number of partitions** possible after optimally choosing one change.

---

### ðŸš€ Approach

**Idea:**
Use **Dynamic Programming with bitmasking** to efficiently track distinct characters in each partition.
Each character is represented as a bit (`a` â†’ 1, `b` â†’ 2, etc.).
We explore every index with or without using the one allowed change.

---

### ðŸ’¡ DP State

`dp(i, can_change, mask)`

* `i`: current index in the string
* `can_change`: whether the one modification is still available (1 or 0)
* `mask`: bitmask of distinct letters in the current partition

---

### ðŸ” Transition

1. **Continue current partition:**
   If adding `s[i]` keeps â‰¤ `k` distinct chars â†’ continue.
   Otherwise, start a new partition.

2. **Try modifying one character:**
   If `can_change` is true, simulate changing `s[i]` to any letter `'a'..'z'`.
   Update `mask` and recurse with `can_change = 0`.

---

### âš¡ï¸ Optimization

* Use Pythonâ€™s `@cache` to memoize `(i, can_change, mask)` states.
* Use `bit_count()` to quickly count distinct letters.
* Each state only processes `O(26)` branches â†’ runs efficiently for `n â‰¤ 10â´`.

---

### ðŸ§  Complexity

* **Time:** `O(n * 26 * 2)` (each character Ã— change status Ã— alphabet)
* **Space:** `O(n * 2 * 2^k)` via caching, but `mask` compresses efficiently.

---

### ðŸ§© Code

```python
from functools import cache

class Solution:
    def maxPartitionsAfterOperations(self, s: str, k: int) -> int:
        n = len(s)
        masks = [1 << (ord(c) - ord('a')) for c in s]

        @cache
        def dp(i, can_change, mask):
            if i == n:
                return 0
            new_mask = mask | masks[i]
            res = 0
            if new_mask.bit_count() > k:
                res = 1 + dp(i + 1, can_change, masks[i])
            else:
                res = dp(i + 1, can_change, new_mask)
            if can_change:
                for j in range(26):
                    changed_mask = mask | (1 << j)
                    if changed_mask.bit_count() > k:
                        res = max(res, 1 + dp(i + 1, 0, 1 << j))
                    else:
                        res = max(res, dp(i + 1, 0, changed_mask))
            return res

        return dp(0, 1, 0) + 1
```
### ðŸ”¹ Why Itâ€™s Efficient

Each state (i, can_change, mask) is cached.

Bitmask operations are O(1).

At most O(26 * n * 2) states, manageable for n â‰¤ 10^4.

