# üß† [Find Sum of Array Product of Magical Sequences](https://leetcode.com/problems/find-sum-of-array-product-of-magical-sequences/description) ‚Äî Notes

### **Problem Summary**

We‚Äôre given integers `m`, `k`, and an array `nums`.
We must find the sum of products of all sequences `seq` of length `m`
(where each element is an index into `nums`) such that:

[
\text{popcount}(2^{seq[0]} + 2^{seq[1]} + ... + 2^{seq[m-1]}) = k
]

and
[
\text{prod(seq)} = nums[seq[0]] \times nums[seq[1]] \times ... \times nums[seq[m-1]]
]

Return the total sum of all such products **mod 1e9 + 7**.

---

## üå± Intuition

### 1. Binary View

Each index `i` contributes `2^i` to a sum.
When indices repeat, carries occur in binary addition.

Example:

```
indices = [0, 0, 1]
sum = 2^0 + 2^0 + 2^1 = 4  (binary 100)
```

Notice how the extra `2^0` carried into higher bits.

We only care about how many bits are **1** after all carries ‚Üí that‚Äôs the `k`.

---

### 2. State Definition

We define a recursive DP that tracks:

* `r` ‚Üí remaining elements to pick
* `n` ‚Üí number of set bits we still need
* `i` ‚Üí current index in `nums`
* `c` ‚Üí carry from previous bits

So the function:

```python
f(r, n, i, c)
```

returns the total sum of products possible with these parameters.

---

### 3. Transitions

At each index `i`, we can choose `t` elements of that index (`0 ‚â§ t ‚â§ r`):

* Each contributes `t * 2^i` to the binary sum
* The new carry becomes `nc = c + t`
* The bit at this position becomes `nc % 2`
* The carry to next position is `nc // 2`
* The product contribution = `nums[i]^t`
* The count of arrangements = `C(r, t)` (combinations)

Then we recurse to next index.

---

### 4. Base Conditions

* If `r == 0`:
  ‚Üí check if remaining carry has exactly `n` bits set
* If `i == len(nums)` and still need bits ‚Üí invalid
* If `r + bin(c).count('1') < n`:
  ‚Üí impossible to reach `n` bits ‚Üí prune early

---

### 5. Recurrence Relation

[
f(r, n, i, c) = \sum_{t=0}^{r} \binom{r}{t} \cdot nums[i]^t \cdot f(r - t, n - (nc \bmod 2), i + 1, nc // 2)
]
where `nc = c + t`

---

### 6. Memoization

We memoize with key `(r, n, i, c)` since states repeat.

---

## üßÆ Code

```python
class Solution(object):
    def magicalSum(self, m, k, nums):
        M = 10**9 + 7
        l = len(nums)
        d = {}
        
        def f(r, n, i, c):
            # pruning
            if r < 0 or n < 0 or r + bin(c).count('1') < n:
                return 0
            # base case
            if r == 0:
                return 1 if n == bin(c).count('1') else 0
            if i >= l:
                return 0
            
            key = (r, n, i, c)
            if key in d:
                return d[key]
            
            res = 0
            for t in range(r + 1):
                # combination: C(r, t)
                w = 1
                for j in range(t):
                    w = w * (r - j) // (j + 1)
                w %= M
                
                v = pow(nums[i], t, M)
                nc = c + t
                res = (res + w * v % M * f(r - t, n - (nc % 2), i + 1, nc // 2)) % M
            
            d[key] = res
            return res
        
        return f(m, k, 0, 0)
```

---

## ‚è±Ô∏è **Complexity**

| Type      | Complexity                                                      |
| --------- | --------------------------------------------------------------- |
| **Time**  | `O(n * m¬≤ * k)` (approx., since we try t=0..r at each state)    |
| **Space** | `O(n * m * k * possible_carry)` (due to memoization dictionary) |

---

## üß© Key Takeaways

* Carry simulation is the *heart* of the problem.
* Each bit position handled independently via recursion.
* Combinatorial factor `C(r, t)` counts arrangement of identical indices.
* `bin(c).count('1')` helps ensure popcount correctness.
* This is a rare example of **carry-aware DP**, blending **bit manipulation + combinatorics**.


