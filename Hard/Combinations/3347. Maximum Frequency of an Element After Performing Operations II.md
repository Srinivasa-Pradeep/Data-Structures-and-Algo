### [Maximum Frequency of an Element After Performing Operations II](https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-ii/description/) - Notes

We’re finding the **maximum frequency** of any number in an array after performing at most `numOperations`, where each operation allows increasing or decreasing a number by at most `k`.

### 💡 Core Idea

* Sort the array first.
* For each number `x`, find how many numbers fall in the range `[x - k, x + k]`.
* Count how many operations can make others equal to `x`.
* Track the maximum frequency achievable.

Two cases:

1. **Direct frequency window around `x`** → count within range `[x - k, x + k]`
2. **No fixed target number (`x`)** → use two-pointer sliding window for numbers within `2*k` difference.

---

### 🧠 Algorithm Summary

1. **Sort `nums`**
2. For each unique value `x`:

   * Move `left` and `right` pointers to find numbers within `[x - k, x + k]`
   * Count occurrences of `x`
   * Compute possible max frequency = `min(right - left, cnt_x + numOperations)`
3. Handle edge case: when no specific number is fixed, compute the longest range where `nums[right] - nums[left] <= 2*k`
4. Return the best among both cases.

---

### ⏱️ Time Complexity

* Sorting: `O(n log n)`
* Sliding window traversal: `O(n)`
  ✅ Overall: **O(n log n)**

### 💾 Space Complexity

* Only pointers and counters → **O(1)**

---

### 🧠 Code Snippet

```python
class Solution:
    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:
        nums.sort()
        n = len(nums)
        res = 0
        left = 0
        right = 0
        i = 0 
        
        # Case 1: Fixing a target x
        while i < n:
            x = nums[i]
            j = i 
            cnt_x = 0
            while j < n and nums[j] == x:
                cnt_x += 1
                j += 1
            while left < n and nums[left] < x - k:
                left += 1
            while right < n and nums[right] <= x + k:   
                right += 1
            res = max(res, min(right - left, cnt_x + numOperations))
            i = j
        
        # Case 2: No fixed target
        if res >= numOperations:
            return res 
        res_no_x = 0
        left = 0
        for right, x in enumerate(nums):
            while nums[left] < x - k * 2:
                left += 1
            res_no_x = max(res_no_x, right - left + 1)
        
        res_no_x = min(res_no_x, numOperations)
        return max(res, res_no_x)
```


