# [Movie Renting System](https://leetcode.com/problems/design-movie-rental-system/description/) – Learning & Code Summary

## Problem Understanding

We are implementing a **movie renting system** with multiple shops. The system supports:

1. **Search** – Find cheapest 5 shops with an **unrented copy** of a movie.
2. **Rent** – Rent a movie from a shop.
3. **Drop** – Return a previously rented movie.
4. **Report** – Return cheapest 5 rented movies.

**Key constraints:**

* Each shop has **at most one copy** of a movie.
* Operations (`search`, `rent`, `drop`, `report`) are called **up to 10^5 times**.
* Sorting rules:

  * For search: price → shop ID.
  * For report: price → shop ID → movie ID.

---

## Step 1: How to Think About the Problem

1. Each movie has a **collection of available copies** (heap or sorted structure).
2. **Rented movies** have a separate collection (heap or sorted structure).
3. **Price dictionary** allows quick lookup of any `(shop, movie)` pair.

**Core idea:** Move movies between **available** and **rented** collections as they are rented or dropped.

---

## Step 2: Data Structures

### Lazy-deletion version:

* `available[movie]` → min-heap `(price, shop)`.
* `rented` → min-heap `(price, shop, movie)`.
* `rented_set` → set of rented `(shop, movie)` for lazy-deletion.
* `price` → dict `(shop, movie) → price`.

### Optimized “Master” version:

* `available[movie]` → `SortedList` of `(price, shop)` (auto sorted, supports O(log n) insertion/removal).
* `rented` → `SortedList` of `(price, shop, movie)` for report.
* `price` → dict `(shop, movie) → price`.

---

## Step 3: Operations – Mental Map

### 1. Search

* Look at **available collection** for the movie.
* Collect **top 5 cheapest shops**.
* Lazy-deletion: skip rented movies (if using heap).
* Optimized: only valid entries → direct slice.

### 2. Rent

* Remove `(price, shop)` from available collection.
* Add `(price, shop, movie)` to rented collection.
* Update `rented_set` if using lazy-deletion.

### 3. Drop

* Remove `(price, shop, movie)` from rented collection.
* Add `(price, shop)` back to available collection.
* Update `rented_set` if using lazy-deletion.

### 4. Report

* Return **top 5 cheapest rented movies** from rented collection.
* Format as `[shop, movie]`.

---

## Step 4: Why Heaps / SortedLists

* **Min-heap**: automatically gives cheapest elements first.
* **SortedList**: supports **O(log n) insertion/deletion** of specific elements → no lazy-deletion needed.
* **Dictionary for price**: O(1) lookup for `(shop, movie)` price.

---

## Step 5: Python Optimized Implementation

```python
from sortedcontainers import SortedList

class MovieRentingSystem:

    def __init__(self, n, entries):
        self.available = {}
        self.rented = SortedList()
        self.price = {}

        # Initialize available movies and their prices
        for shop, movie, p in entries:
            self.price[(shop, movie)] = p
            if movie not in self.available:
                self.available[movie] = SortedList()
            self.available[movie].add((p, shop))

    def search(self, movie):
        if movie not in self.available:
            return []
        # Return top 5 cheapest available shops
        return [shop for price, shop in self.available[movie][:5]]

    def rent(self, shop, movie):
        price = self.price[(shop, movie)]
        # Remove from available
        self.available[movie].remove((price, shop))
        # Add to rented
        self.rented.add((price, shop, movie))

    def drop(self, shop, movie):
        price = self.price[(shop, movie)]
        # Remove from rented
        self.rented.remove((price, shop, movie))
        # Add back to available
        self.available[movie].add((price, shop))

    def report(self):
        # Return top 5 cheapest rented movies
        return [[shop, movie] for price, shop, movie in self.rented[:5]]
```

---

## Step 6: Workflow Story

1. **System initialized** → all movies in available collections.
2. **Search** → top 5 shops returned by price → shop ID.
3. **Rent** → move movie to rented collection.
4. **Drop** → move movie back to available collection.
5. **Report** → top 5 cheapest rented movies returned.

---

## Step 7: Key Brain Takeaways

* Always **keep collections clean** → only valid entries.
* Heaps are good for top element queries, but **SortedList/TreeSet** is better for fast arbitrary removal.
* Use **price dictionary** → O(1) price lookup.
* Optimize search/report using slicing → O(5) retrieval.

---

