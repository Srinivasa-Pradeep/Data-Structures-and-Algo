# [Swim in Rising Water](https://leetcode.com/problems/swim-in-rising-water/description/) ‚Äî Notes

## üîç Problem Summary

You‚Äôre given an `n x n` grid where each cell‚Äôs value represents the **time when water rises** high enough to enter that cell.

You start from `(0,0)` and must reach `(n-1,n-1)`.
At any time `t`, you can only move to cells where `grid[i][j] <= t`.

Find the **minimum time `t`** when you can reach the bottom-right cell.

---

## üí° Intuition

Think of the grid as a mountain of heights, and water is rising over time.

* At time `t`, all cells with height ‚â§ `t` are flooded.
* You can move only through flooded cells.
* We want the **minimum t** that lets us go from start to end.

So, we‚Äôre finding a **path from (0,0) to (n-1,n-1)**
where the **maximum height** along that path is **as small as possible**.

This is a **minimum "maximum edge weight" path problem** ‚Äî a perfect case for a **min-heap (priority queue)**.

---

## ‚öôÔ∏è Algorithm (Step-by-Step)

### 1. Setup

* Create a **min-heap** (priority queue) starting from `(grid[0][0], 0, 0)`.

  * The first value in the tuple (`grid[0][0]`) represents the **current water level** needed to step there.
* Keep a **visited set** to avoid re-processing the same cells.
* Define directions for 4-way movement:

  ```python
  DIRS = [(1,0), (-1,0), (0,1), (0,-1)]
  ```

---

### 2. Processing the Heap

While the heap isn‚Äôt empty:

1. **Pop** the cell with the smallest current water level:

   ```python
   water, row, col = heapq.heappop(heap)
   ```

   * This means this cell is reachable at this water level `water`.

2. If `(row, col)` is the destination `(n-1, n-1)` ‚Üí **return water**
   because this is the **earliest possible time** you can reach it.

3. Otherwise, for each **neighboring cell**:

   * Check if it‚Äôs **within bounds** and **not visited**.
   * Mark it as visited.
   * Calculate the **water level needed** to move there:

     ```python
     next_water = max(grid[next_r][next_c], water)
     ```

     Because if the neighbor‚Äôs height is higher than current water,
     you must **wait until** that height is flooded.

4. Push it to the heap:

   ```python
   heapq.heappush(heap, (next_water, next_r, next_c))
   ```

---

### 3. Return Statement

If we somehow exit the loop without reaching `(n-1,n-1)`,
we return `-1` as a **safety fallback** (theoretically impossible for this problem).

---

## üß† Example Trace

### Grid:

```
0  2
1  3
```

**Step 1:**
Start ‚Üí heap = [(0,0,0)]
Pop ‚Üí water=0, position=(0,0)

Push neighbors:

* (1,0): max(1,0)=1
* (0,1): max(2,0)=2
  heap = [(1,1,0),(2,0,1)]

**Step 2:**
Pop (1,1,0): water=1
Push neighbor (1,1): max(3,1)=3
heap = [(2,0,1),(3,1,1)]

**Step 3:**
Pop (2,0,1): water=2
Push neighbor (1,1): already in heap
heap = [(3,1,1)]

**Step 4:**
Pop (3,1,1): water=3 ‚Üí destination reached ‚úÖ

Answer = 3

---

## üèóÔ∏è Code

```python
import heapq

class Solution:
    def swimInWater(self, grid: List[List[int]]) -> int:
        n = len(grid)
        heap = [(grid[0][0], 0, 0)]
        visited = set((0, 0))
        DIRS = [(1,0), (-1,0), (0,1), (0,-1)]

        while heap:
            water, row, col = heapq.heappop(heap)
            if (row, col) == (n-1, n-1):
                return water

            for dr, dc in DIRS:
                nr, nc = row + dr, col + dc
                if 0 <= nr < n and 0 <= nc < n and (nr, nc) not in visited:
                    visited.add((nr, nc))
                    next_water = max(water, grid[nr][nc])
                    heapq.heappush(heap, (next_water, nr, nc))

        return -1
```

---

## üß© Complexity Analysis

| Type     | Description                                                   | Complexity |
| -------- | ------------------------------------------------------------- | ---------- |
| ‚è±Ô∏è Time  | Each cell is pushed & popped once from heap                   |**O(n¬≤ log n)**|
| üß† Space | Heap + visited set                                            |**O(n¬≤)**      |

---

## üß≠ Optimization Insights

‚úÖ **Why min-heap?**
We always expand the cell reachable with the **smallest water level so far**, like Dijkstra‚Äôs algorithm.

‚úÖ **Why take `max(water, grid[nr][nc])`?**
Because even if you reach a higher cell, you must wait until water rises to that height.

‚úÖ **Why mark visited early?**
So we don‚Äôt push duplicates into heap, keeping runtime clean.

‚úÖ **Why return -1 at the end?**
Just a **fallback**; the path always exists, but functions should always return something.

---

## üí¨ Key Takeaways

* The problem is a **Dijkstra variant** on a grid.
* The "weight" of a cell is its height.
* You‚Äôre minimizing the **maximum height along the path**.
* Min-heap ensures we expand **safest (lowest water) paths first**.
* Time complexity is **O(n¬≤ log n)** ‚Äî optimal for this type of grid problem.


