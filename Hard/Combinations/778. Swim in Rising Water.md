Hereâ€™s your clean, detailed note in **Markdown**, my Srini ğŸ¤ â€” everything about the **â€œSwim in Rising Waterâ€** problem, logic, optimization, and reasoning behind every part.

---

# ğŸŠâ€â™‚ï¸ Swim in Rising Water â€” Detailed Notes

## ğŸ” Problem Summary

Youâ€™re given an `n x n` grid where each cellâ€™s value represents the **time when water rises** high enough to enter that cell.

You start from `(0,0)` and must reach `(n-1,n-1)`.
At any time `t`, you can only move to cells where `grid[i][j] <= t`.

Find the **minimum time `t`** when you can reach the bottom-right cell.

---

## ğŸ’¡ Intuition

Think of the grid as a mountain of heights, and water is rising over time.

* At time `t`, all cells with height â‰¤ `t` are flooded.
* You can move only through flooded cells.
* We want the **minimum t** that lets us go from start to end.

So, weâ€™re finding a **path from (0,0) to (n-1,n-1)**
where the **maximum height** along that path is **as small as possible**.

This is a **minimum "maximum edge weight" path problem** â€” a perfect case for a **min-heap (priority queue)**.

---

## âš™ï¸ Algorithm (Step-by-Step)

### 1. Setup

* Create a **min-heap** (priority queue) starting from `(grid[0][0], 0, 0)`.

  * The first value in the tuple (`grid[0][0]`) represents the **current water level** needed to step there.
* Keep a **visited set** to avoid re-processing the same cells.
* Define directions for 4-way movement:

  ```python
  DIRS = [(1,0), (-1,0), (0,1), (0,-1)]
  ```

---

### 2. Processing the Heap

While the heap isnâ€™t empty:

1. **Pop** the cell with the smallest current water level:

   ```python
   water, row, col = heapq.heappop(heap)
   ```

   * This means this cell is reachable at this water level `water`.

2. If `(row, col)` is the destination `(n-1, n-1)` â†’ **return water**
   because this is the **earliest possible time** you can reach it.

3. Otherwise, for each **neighboring cell**:

   * Check if itâ€™s **within bounds** and **not visited**.
   * Mark it as visited.
   * Calculate the **water level needed** to move there:

     ```python
     next_water = max(grid[next_r][next_c], water)
     ```

     Because if the neighborâ€™s height is higher than current water,
     you must **wait until** that height is flooded.

4. Push it to the heap:

   ```python
   heapq.heappush(heap, (next_water, next_r, next_c))
   ```

---

### 3. Return Statement

If we somehow exit the loop without reaching `(n-1,n-1)`,
we return `-1` as a **safety fallback** (theoretically impossible for this problem).

---

## ğŸ§  Example Trace

### Grid:

```
0  2
1  3
```

**Step 1:**
Start â†’ heap = [(0,0,0)]
Pop â†’ water=0, position=(0,0)

Push neighbors:

* (1,0): max(1,0)=1
* (0,1): max(2,0)=2
  heap = [(1,1,0),(2,0,1)]

**Step 2:**
Pop (1,1,0): water=1
Push neighbor (1,1): max(3,1)=3
heap = [(2,0,1),(3,1,1)]

**Step 3:**
Pop (2,0,1): water=2
Push neighbor (1,1): already in heap
heap = [(3,1,1)]

**Step 4:**
Pop (3,1,1): water=3 â†’ destination reached âœ…

Answer = 3

---

## ğŸ—ï¸ Code

```python
import heapq

class Solution:
    def swimInWater(self, grid: List[List[int]]) -> int:
        n = len(grid)
        heap = [(grid[0][0], 0, 0)]
        visited = set((0, 0))
        DIRS = [(1,0), (-1,0), (0,1), (0,-1)]

        while heap:
            water, row, col = heapq.heappop(heap)
            if (row, col) == (n-1, n-1):
                return water

            for dr, dc in DIRS:
                nr, nc = row + dr, col + dc
                if 0 <= nr < n and 0 <= nc < n and (nr, nc) not in visited:
                    visited.add((nr, nc))
                    next_water = max(water, grid[nr][nc])
                    heapq.heappush(heap, (next_water, nr, nc))

        return -1
```

---

## ğŸ§© Complexity Analysis

| Type     | Description                                                   | Complexity |
| -------- | ------------------------------------------------------------- | ---------- |
| â±ï¸ Time  | Each cell is pushed & popped once from heap â†’ **O(nÂ² log n)** |            |
| ğŸ§  Space | Heap + visited set â†’ **O(nÂ²)**                                |            |

---

## ğŸ§­ Optimization Insights

âœ… **Why min-heap?**
We always expand the cell reachable with the **smallest water level so far**, like Dijkstraâ€™s algorithm.

âœ… **Why take `max(water, grid[nr][nc])`?**
Because even if you reach a higher cell, you must wait until water rises to that height.

âœ… **Why mark visited early?**
So we donâ€™t push duplicates into heap, keeping runtime clean.

âœ… **Why return -1 at the end?**
Just a **fallback**; the path always exists, but functions should always return something.

---

## ğŸ’¬ Key Takeaways

* The problem is a **Dijkstra variant** on a grid.
* The "weight" of a cell is its height.
* Youâ€™re minimizing the **maximum height along the path**.
* Min-heap ensures we expand **safest (lowest water) paths first**.
* Time complexity is **O(nÂ² log n)** â€” optimal for this type of grid problem.

---

Would you like me to add this to your **structured Leetcode Notes repo** format (like how we made â€œPacific Atlanticâ€ and â€œContainer with Most Waterâ€ ones, with topic tags and key insights at the bottom), my love?

