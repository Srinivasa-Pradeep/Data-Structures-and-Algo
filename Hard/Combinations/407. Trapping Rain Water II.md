# [Trapping Rain Water II](https://leetcode.com/problems/trapping-rain-water-ii/description/) – Heap + BFS Approach

## Problem
- Given an `m x n` integer matrix `heightMap` representing heights of a 2D grid.  
- Compute **how much water can be trapped after raining**.

### Examples

**Example 1:**
```

heightMap = [[1,4,3,1,3,2],
[3,2,1,3,2,4],
[2,3,3,2,3,1]]
Output: 4

```

**Example 2:**
```

heightMap = [[3,3,3,3,3],
[3,2,2,2,3],
[3,2,1,2,3],
[3,2,2,2,3],
[3,3,3,3,3]]
Output: 10

````

---

## Core Idea
1. **Water trapping principle:** A cell can hold water if it is lower than its surrounding boundary.  
2. **2D extension:**  
   - In 1D, water is trapped between the left and right maximum bars.  
   - In 2D, water is trapped by the **minimum height of all surrounding walls**.  
3. **Observation:**  
   - Water always “flows” from the **lowest boundary** inward.  
   - If a neighbor is lower than the current boundary → water fills it up.  
   - If neighbor is higher → it acts as a new boundary.

---

## Algorithm (Heap + BFS)

1. **Initialization:**
   - Create a `visited` matrix same size as `heightMap`.  
   - Push all **boundary cells** into a **min-heap** with their height.  
   - Mark all boundary cells as visited.

2. **Processing:**
   - While heap is not empty:  
     a. Pop the cell with **minimum height**.  
     b. Explore its 4 neighbors (up, down, left, right).  
     c. For each unvisited neighbor:  
        - If neighbor height < current boundary → **water trapped = boundary - neighbor**  
        - Push neighbor into heap with **height = max(boundary, neighbor)**  
        - Mark neighbor as visited.

3. **Result:**  
   - Sum all trapped water.

---

## Complexity
- **Time:** O(m × n × log(m × n)) — each cell pushed/popped once, log factor from heap.  
- **Space:** O(m × n) — visited matrix + heap.  
- Efficient for `m, n ≤ 200`.

---

## Python Code

```python
from heapq import heappush, heappop

class Solution:
    def trapRainWater(self, heightMap: list[list[int]]) -> int:
        if not heightMap or not heightMap[0]:
            return 0
        
        m, n = len(heightMap), len(heightMap[0])
        visited = [[False]*n for _ in range(m)]
        heap = []
        
        # Push all boundary cells
        for i in range(m):
            for j in range(n):
                if i in (0, m-1) or j in (0, n-1):
                    heappush(heap, (heightMap[i][j], i, j))
                    visited[i][j] = True
        
        trapped = 0
        dirs = [(1,0), (-1,0), (0,1), (0,-1)]
        
        while heap:
            h, x, y = heappop(heap)
            for dx, dy in dirs:
                nx, ny = x+dx, y+dy
                if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:
                    visited[nx][ny] = True
                    nh = heightMap[nx][ny]
                    trapped += max(0, h - nh)
                    heappush(heap, (max(h, nh), nx, ny))
        
        return trapped
````

---

## Mental Notes / Tips

* **Think in terms of “water flowing from the outside in.”**
* Always **expand from the lowest wall first** — heap guarantees this.
* Each neighbor’s “effective height” is **max(current water, terrain)**.
* Avoid thinking in 1D left/right max; 2D requires **minimum surrounding boundary** concept.

---

## Visualization Example (5×5 Bowl)

Initial `heightMap`:

```
3 3 3 3 3
3 1 1 1 3
3 1 0 1 3
3 1 1 1 3
3 3 3 3 3
```

**Step-by-step trapped water:**

```
3 3 3 3 3
3 ~ ~ ~ 3
3 ~ W ~ 3
3 ~ ~ ~ 3
3 3 3 3 3
```

* `~` = water filled up to surrounding boundary
* `W` = deepest point, gets most water

**Water trapped per cell:**

```
(1,1): 2
(1,2): 2
(1,3): 2
(2,1): 2
(2,2): 3
(2,3): 2
(3,1): 2
(3,2): 2
(3,3): 2
```

**Total trapped water:** 10 units

**Key idea:** water fills **up to the lowest surrounding boundary**, expanding inward, never overflowing outside.

```

---

Da, this is now **full, clean, grounded**, with topic, explanation, algorithm, code, and a visualization example so it clicks in your head.  

If you want, I can also **make a tiny 1-page “cheat-sheet style diagram” for all steps** so it’s super fast to revise.  

Do you want me to do that?
```

