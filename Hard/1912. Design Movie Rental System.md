Absolutely da ü§ç! Here‚Äôs the **full Markdown version** including everything we learned **plus the optimized Python code**. You can use this for revision anytime.

---

# Movie Renting System ‚Äì Learning & Code Summary

## Problem Understanding

We are implementing a **movie renting system** with multiple shops. The system supports:

1. **Search** ‚Äì Find cheapest 5 shops with an **unrented copy** of a movie.
2. **Rent** ‚Äì Rent a movie from a shop.
3. **Drop** ‚Äì Return a previously rented movie.
4. **Report** ‚Äì Return cheapest 5 rented movies.

**Key constraints:**

* Each shop has **at most one copy** of a movie.
* Operations (`search`, `rent`, `drop`, `report`) are called **up to 10^5 times**.
* Sorting rules:

  * For search: price ‚Üí shop ID.
  * For report: price ‚Üí shop ID ‚Üí movie ID.

---

## Step 1: How to Think About the Problem

1. Each movie has a **collection of available copies** (heap or sorted structure).
2. **Rented movies** have a separate collection (heap or sorted structure).
3. **Price dictionary** allows quick lookup of any `(shop, movie)` pair.

**Core idea:** Move movies between **available** and **rented** collections as they are rented or dropped.

---

## Step 2: Data Structures

### Lazy-deletion version:

* `available[movie]` ‚Üí min-heap `(price, shop)`.
* `rented` ‚Üí min-heap `(price, shop, movie)`.
* `rented_set` ‚Üí set of rented `(shop, movie)` for lazy-deletion.
* `price` ‚Üí dict `(shop, movie) ‚Üí price`.

### Optimized ‚ÄúMaster‚Äù version:

* `available[movie]` ‚Üí `SortedList` of `(price, shop)` (auto sorted, supports O(log n) insertion/removal).
* `rented` ‚Üí `SortedList` of `(price, shop, movie)` for report.
* `price` ‚Üí dict `(shop, movie) ‚Üí price`.

---

## Step 3: Operations ‚Äì Mental Map

### 1. Search

* Look at **available collection** for the movie.
* Collect **top 5 cheapest shops**.
* Lazy-deletion: skip rented movies (if using heap).
* Optimized: only valid entries ‚Üí direct slice.

### 2. Rent

* Remove `(price, shop)` from available collection.
* Add `(price, shop, movie)` to rented collection.
* Update `rented_set` if using lazy-deletion.

### 3. Drop

* Remove `(price, shop, movie)` from rented collection.
* Add `(price, shop)` back to available collection.
* Update `rented_set` if using lazy-deletion.

### 4. Report

* Return **top 5 cheapest rented movies** from rented collection.
* Format as `[shop, movie]`.

---

## Step 4: Why Heaps / SortedLists

* **Min-heap**: automatically gives cheapest elements first.
* **SortedList**: supports **O(log n) insertion/deletion** of specific elements ‚Üí no lazy-deletion needed.
* **Dictionary for price**: O(1) lookup for `(shop, movie)` price.

---

## Step 5: Python Optimized Implementation

```python
from sortedcontainers import SortedList

class MovieRentingSystem:

    def __init__(self, n, entries):
        self.available = {}
        self.rented = SortedList()
        self.price = {}

        # Initialize available movies and their prices
        for shop, movie, p in entries:
            self.price[(shop, movie)] = p
            if movie not in self.available:
                self.available[movie] = SortedList()
            self.available[movie].add((p, shop))

    def search(self, movie):
        if movie not in self.available:
            return []
        # Return top 5 cheapest available shops
        return [shop for price, shop in self.available[movie][:5]]

    def rent(self, shop, movie):
        price = self.price[(shop, movie)]
        # Remove from available
        self.available[movie].remove((price, shop))
        # Add to rented
        self.rented.add((price, shop, movie))

    def drop(self, shop, movie):
        price = self.price[(shop, movie)]
        # Remove from rented
        self.rented.remove((price, shop, movie))
        # Add back to available
        self.available[movie].add((price, shop))

    def report(self):
        # Return top 5 cheapest rented movies
        return [[shop, movie] for price, shop, movie in self.rented[:5]]
```

---

## Step 6: Workflow Story

1. **System initialized** ‚Üí all movies in available collections.
2. **Search** ‚Üí top 5 shops returned by price ‚Üí shop ID.
3. **Rent** ‚Üí move movie to rented collection.
4. **Drop** ‚Üí move movie back to available collection.
5. **Report** ‚Üí top 5 cheapest rented movies returned.

---

## Step 7: Key Brain Takeaways

* Always **keep collections clean** ‚Üí only valid entries.
* Heaps are good for top element queries, but **SortedList/TreeSet** is better for fast arbitrary removal.
* Use **price dictionary** ‚Üí O(1) price lookup.
* Optimize search/report using slicing ‚Üí O(5) retrieval.

---

Da, if you want, I can also **draw a little diagram showing movies moving between Available ‚Üî Rented**. It will make this super visual and easy to remember.

Do you want me to make that diagram too?

