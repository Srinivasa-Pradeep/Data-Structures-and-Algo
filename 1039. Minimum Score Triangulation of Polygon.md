# Minimum Score Triangulation of Polygon

## Problem Understanding
- Given a **convex n-sided polygon** with each vertex having an integer value.
- **Triangulation**: divide the polygon into triangles using its vertices.
- Each triangle’s **score** = product of its 3 vertices.
- Total score = sum of all triangles’ scores.
- Goal: **find the minimum total score** over all possible triangulations.

### Examples

1. `values = [1,2,3]`  
   - Only triangle possible: `(1,2,3)`  
   - Score = `1 * 2 * 3 = 6`  

2. `values = [3,7,4,5]`  
   - Triangulation options:  
     - `(3,7,5)` & `(7,4,5)` → 245  
     - `(3,4,5)` & `(3,4,7)` → 144  
   - Minimum = 144  

3. `values = [1,3,1,4,1,5]` → Minimum score = 13  

---

## Approach (Dynamic Programming)

### Key Idea
- Let `dp[i][j]` = minimum score to triangulate the polygon **between vertices i and j**.
- For a polygon from `i` to `j`, pick a middle vertex `k` (`i < k < j`) and split into:
  1. Left polygon: `dp[i][k]`
  2. Right polygon: `dp[k][j]`
  3. Triangle formed: `values[i] * values[k] * values[j]`
- Formula:  
```

dp[i][j] = min(dp[i][k] + dp[k][j] + values[i]*values[k]*values[j]) for all k in (i+1, j-1)

```
- **Base case**: if `j - i < 2` → no triangle → `dp[i][j] = 0`

### Iterative Computation
- Start from small polygons (length 3) and grow to the full polygon.
- Fill the `dp` table iteratively.

---

## Example Walkthrough
`values = [1,3,1,4]`  

1. Initialize `dp[i][j] = 0` if `j-i < 2`  

2. Compute triangles of length 3:
```

dp[0][2] = 1*3*1 = 3
dp[1][3] = 3*1*4 = 12

````

3. Compute full polygon `dp[0][3]`:
- k = 1 → cost = dp[0][1] + dp[1][3] + 1*3*4 = 0 + 12 + 12 = 24
- k = 2 → cost = dp[0][2] + dp[2][3] + 1*1*4 = 3 + 0 + 4 = 7
- Minimum → dp[0][3] = 7

---

## Python Code

```python
from math import inf

def minScoreTriangulation(values):
 n = len(values)
 dp = [[0] * n for _ in range(n)]
 
 for length in range(3, n+1):
     for i in range(n - length + 1):
         j = i + length - 1
         dp[i][j] = inf
         for k in range(i+1, j):
             cost = dp[i][k] + dp[k][j] + values[i]*values[k]*values[j]
             dp[i][j] = min(dp[i][j], cost)
 
 return dp[0][n-1]

# Test
values = [1,3,1,4]
print(minScoreTriangulation(values))  # Output: 7
````

---

## Key Takeaways

1. Break problems into smaller subproblems (DP principle).
2. `dp[i][j]` always represents **minimum score between i and j**.
3. Try all possible middle points to find minimum cost.
4. Start small, then iteratively solve bigger polygons.

```

---

If you want, da, I can also **draw a tiny diagram for the polygon split** and add it to the notes—it makes it super easy to visualize. Do you want me to do that?
```

