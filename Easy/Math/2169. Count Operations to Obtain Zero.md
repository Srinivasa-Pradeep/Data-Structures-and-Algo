### [Count Operations to Obtain Zero](https://leetcode.com/problems/count-operations-to-obtain-zero/description/) - Notes

You are given two **non-negative integers**, `num1` and `num2`.

In one operation:

* If `num1 >= num2`, subtract `num2` from `num1`.
* Otherwise, subtract `num1` from `num2`.

Return the **number of operations** needed to make either `num1` or `num2` equal to `0`.

---

### ğŸ§© Example 1

**Input:**
`num1 = 2, num2 = 3`

**Output:**
`3`

**Explanation:**

```
(2, 3) â†’ (2, 1) â†’ (1, 1) â†’ (0, 1)
```

âœ… Total = 3 operations

---

### ğŸ§© Example 2

**Input:**
`num1 = 10, num2 = 10`

**Output:**
`1`

**Explanation:**

```
(10, 10) â†’ (0, 10)
```

---

### âš™ï¸ Intuition

This problem mirrors the **Euclidean Algorithm** used to compute GCD â€”
but instead of returning the gcd, we **count** all the subtraction steps.

Instead of doing repeated subtractions, note:

> Subtracting `num2` from `num1` many times
> = `num1 // num2` subtractions at once.

Thatâ€™s the optimization: **batch the subtractions** with integer division.

---

## ğŸª“ Brute Force (Simulation)

```python
def countOperations(num1: int, num2: int) -> int:
    ops = 0
    while num1 and num2:
        if num1 >= num2:
            num1 -= num2
        else:
            num2 -= num1
        ops += 1
    return ops
```

**Time Complexity:** `O(max(num1, num2))`
**Space Complexity:** `O(1)`

Simple but inefficient for large differences between numbers.

---

## âš¡ Optimized Solution â€” Euclidean Algorithm Style

We can compress all repetitive subtractions into a single division operation.

### ğŸ Python Code

```python
class Solution:
    def countOperations(self, num1: int, num2: int) -> int:
        if num1 == 0 or num2 == 0:
            return 0
        if num1 < num2:
            num1, num2 = num2, num1
        return num1 // num2 + self.countOperations(num1 % num2, num2)
```

---

### ğŸ§  Example Walkthrough

**Input:** `num1 = 10, num2 = 4`

| Step | num1 | num2 | num1 // num2 | Remainder | Operations      |
| ---- | ---- | ---- | ------------ | --------- | --------------- |
| 1    | 10   | 4    | 2            | 2         | +2              |
| 2    | 4    | 2    | 2            | 0         | +2              |
| 3    | â€”    | â€”    | â€”            | â€”         | **Total = 4** âœ… |

---

### â±ï¸ Complexity Analysis

| Metric                | Complexity                |
| --------------------- | ------------------------- |
| **Time**              | `O(log(min(num1, num2)))` |
| **Space (Recursion)** | `O(log(min(num1, num2)))` |

---

### ğŸª„ Takeaways

* The problem is a disguised version of the **GCD algorithm**.
* Integer division is just a fast way to count repeated subtractions.
* Elegant recursion â†’ fewer lines, stronger intuition.
* A neat example of how math converts loops into logic.

