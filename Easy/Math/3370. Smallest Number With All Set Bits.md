## [Smallest Number With All Set Bits](https://leetcode.com/problems/smallest-number-with-all-set-bits/description/) - Notes

### ðŸ”¹ Idea

We need the smallest number **â‰¥ n** whose binary representation contains only **1s**.
Such numbers follow the pattern:
`1 (1), 3 (11), 7 (111), 15 (1111), 31 (11111)...`
These are all of the form **`2^k - 1`**.

---

### ðŸ”¹ Why `2^k - 1` Gives All Ones

Letâ€™s look at powers of two:

```
2^1 = 2  â†’ 10  
2^2 = 4  â†’ 100  
2^3 = 8  â†’ 1000  
2^4 = 16 â†’ 10000
```

Now subtract 1 from each:

```
2^1 - 1 = 1   â†’ 1  
2^2 - 1 = 3   â†’ 11  
2^3 - 1 = 7   â†’ 111  
2^4 - 1 = 15  â†’ 1111
```

Subtracting 1 flips all bits below the single `1` into `1`s â†’ you get all set bits.

---

### ðŸ”¹ Bit-Shift Intuition

`1 << k` means shifting `1` left by `k` bits.
Each shift doubles the number:

```
1 << 1 = 2   â†’ 0010  
1 << 2 = 4   â†’ 0100  
1 << 3 = 8   â†’ 1000
```

Subtract 1 to fill in all ones below it:

```
(1 << 3) - 1 = 1000 - 1 = 0111 â†’ 7
```

---

### ðŸ”¹ Code (Python)

```python
class Solution:
    def smallestNumber(self, n: int) -> int:
        x = 1
        while (1 << x) - 1 < n:
            x += 1
        return (1 << x) - 1
```

---

### ðŸ§© Complexity

* **Time Complexity:** `O(log n)` â€” because we increase `x` until `(1 << x) - 1` â‰¥ `n`.
* **Space Complexity:** `O(1)` â€” uses constant extra space.

---

### ðŸ’¡ Key Learnings

* Numbers with all bits set can be generated using `2^k - 1`.
* `(1 << k)` is an efficient way to compute `2^k`.
* Commonly used in problems involving bit masks or binary intervals.
* Shifting and subtracting creates patterns of 1s in binary â€” powerful for optimization.

