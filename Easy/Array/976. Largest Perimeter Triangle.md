# **[Largest Perimeter Triangle](https://leetcode.com/problems/largest-perimeter-triangle/description/) — Notes**

## **Problem**

> Given an integer array `nums`, return the largest perimeter of a triangle with a **non-zero area**, formed from three of these lengths.
> If impossible → return `0`.

**Examples:**

```text
Input: nums = [2,1,2]
Output: 5   # 1 + 2 + 2 forms a triangle

Input: nums = [1,2,1,10]
Output: 0   # No triple can form a valid triangle
```

**Constraints:**

* `3 <= nums.length <= 10^4`
* `1 <= nums[i] <= 10^6`

---

## **Key Concept: Triangle Inequality**

For sides `a <= b <= c`:

[
a + b > c
]

* Only the sum of the **two smaller sides** needs to exceed the **largest side**.
* Equality (`a + b = c`) → zero area → **invalid triangle**.

---

## **Optimal Approach**

1. **Sort the array descending**

   * Largest sides first → ensures **largest perimeter is found first**.

2. **Scan consecutive triples** `(x, y, z)`:

   ```text
   x = largest, y = middle, z = smallest
   check: y + z > x
   ```

3. **Return the first valid perimeter** `x + y + z`.

4. **If no triple works** → return `0`.

---

## **Why This Is Optimal**

* Sorting → `O(n log n)`
* Scanning consecutive triples → `O(n)`
* Total complexity = **O(n log n)** → can’t do better generally
* Checking all combinations (`combinations(nums,3)`) → `O(n^3)` → impractical for large `n`.

---

## **Python “One-Liner-ish” Implementation**

```python
class Solution:
    def largestPerimeter(self, nums: List[int]) -> int:
        nums.sort(reverse=True)
        return next(
            (x + y + z for x, y, z in zip(nums, nums[1:], nums[2:]) if y + z > x), 
            0
        )
```

**Explanation:**

* `zip(nums, nums[1:], nums[2:])` → consecutive triples
* Generator `(x+y+z for ... if y+z>x)` → yields all valid perimeters
* `next(..., 0)` → picks **first valid perimeter**, or `0` if none

**Flow Example:**

```text
nums = [3, 6, 2, 3]
sorted: [6, 3, 3, 2]
triples: (6,3,3) -> 3+3>6? ❌
         (3,3,2) -> 3+2>3 ✅ → perimeter = 8
```

---

## **Alternative (Heap) Approach**

* Use **max-heap** (negate numbers for Python min-heap)
* Pop top 2, peek 3rd → check triangle inequality
* Correct but **more complex**, no speed advantage over sort+scan.

**Takeaway:**

> Sorting + consecutive triples is **simple, elegant, and optimal** for this problem.

---

## **Summary Notes**

* Focus on **triangle inequality**: sum of two smaller sides > largest
* To maximize perimeter → start from **largest sides**
* Python tools for elegance: `zip`, `next`, generator expressions
* Heap is optional but **not needed** here


Do you want me to add that?

