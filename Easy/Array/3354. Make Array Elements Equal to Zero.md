## [Make Array Elements Equal to Zero](https://leetcode.com/problems/make-array-elements-equal-to-zero/description/) - Notes

### 📝 Description

You are given an integer array `nums`.
A valid selection is defined by picking a position `i` where `nums[i] == 0` and a direction (left or right) such that, after simulating the process described in the problem, all elements in `nums` become `0`.

This solution uses a **mathematical observation** instead of simulation.

---

### 💡 Intuition

At each zero index, the array can be divided into:

* **Left part sum:** `left_sum`

* **Right part sum:** `total_sum - left_sum`

* If both sides are equal → **both directions** are valid.

* If their absolute difference is `1` → **only one direction** works.

* Otherwise → no valid selection from that index.

This works because each nonzero element essentially represents a needed "balance" between left and right movements.

---

### ⚙️ Approach

1. Calculate the total sum of all elements.
2. Traverse the array from left to right, maintaining a running prefix sum (`left_sum`).
3. For every `nums[i] == 0`, compare the sums on both sides.
4. Increment the valid count based on the difference condition.
5. Return the total valid selections.

---

### ⏱️ Complexity

* **Time:** `O(n)`
* **Space:** `O(1)`

---

### 🧾 Code (Python)

```python
class Solution:
    def countValidSelections(self, nums: List[int]) -> int:
        total_sum = sum(nums)
        left_sum = 0
        valid = 0
        
        for x in nums:
            right_sum = total_sum - left_sum
            if x == 0:
                diff = abs(right_sum - left_sum)
                if diff == 0:
                    valid += 2   # both directions possible
                elif diff == 1:
                    valid += 1   # only one direction works
            left_sum += x
        
        return valid
```

---

### 🧠 Key Learnings

* Sometimes a problem that looks like simulation can be simplified to math and symmetry.
* Tracking prefix and suffix properties can eliminate heavy looping.
* Clean, one-pass logic often beats brute-force simulation for performance and clarity.

