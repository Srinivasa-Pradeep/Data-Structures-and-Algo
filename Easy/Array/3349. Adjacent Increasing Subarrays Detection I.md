# 🧠 [Adjacent Increasing Subarrays of Length k](https://leetcode.com/problems/adjacent-increasing-subarrays-detection-i/description/) — Notes

### **Problem Summary**

Given an integer array `nums` and an integer `k`,
check if there exist **two adjacent subarrays** of length `k` such that:

* Both are **strictly increasing**
* They are **adjacent**, i.e. second subarray starts exactly after the first ends → `b = a + k`

Return `True` if such two subarrays exist, otherwise `False`.

---

## 🌱 Intuition

The problem is asking whether we can find **two consecutive stretches** of length `k` that are each strictly increasing.

Instead of checking every possible pair independently,
we can **precompute** which subarrays of length `k` are strictly increasing.

Then, we just check if there exists a position `i` such that:

```
subarray[i] is increasing  AND  subarray[i + k] is increasing
```

---

## 🧩 Step-by-Step Thought Process

1. **Strictly Increasing Check**
   For a subarray `nums[i..i+k-1]`, it’s strictly increasing if:

   ```
   nums[i] < nums[i+1] < nums[i+2] < ... < nums[i+k-1]
   ```

2. **Precomputation**

   * Build a boolean array `inc[i]` that is `True` if `nums[i..i+k-1]` is strictly increasing.
   * You can compute it in `O(n*k)` (acceptable since n ≤ 100).

3. **Final Check**

   * Loop through all possible start indices `i`
   * If `inc[i]` and `inc[i + k]` are both `True` → return `True`
   * Else, return `False`

---

## ⚙️ Code (Python)

```python
class Solution:
    def hasTwoIncreasingSubarrays(self, nums, k):
        n = len(nums)
        inc = [False] * (n - k + 1)
        
        # Step 1: Mark increasing subarrays
        for i in range(n - k + 1):
            increasing = True
            for j in range(i, i + k - 1):
                if nums[j] >= nums[j + 1]:
                    increasing = False
                    break
            inc[i] = increasing
        
        # Step 2: Check for two adjacent increasing ones
        for i in range(n - 2*k + 1):
            if inc[i] and inc[i + k]:
                return True
        
        return False
```

---

## ⏱️ **Complexity**

| Type      | Complexity                                     |
| --------- | ---------------------------------------------- |
| **Time**  | `O(n * k)` — check each subarray of length `k` |
| **Space** | `O(n)` — for storing the boolean list `inc`    |

---

## 🧩 Key Takeaways

* A **strictly increasing window** means each pair `nums[j] < nums[j+1]`.
* Two **adjacent** increasing subarrays means their start indices differ by exactly `k`.
* Precomputing which windows are increasing simplifies checking adjacency.
* The approach is clean, readable, and optimal for small constraints (n ≤ 100).

