##  **Problem Recap**

You’re given an integer array `nums` of **non-negative** integers.

You can perform the following operation any number of times:

> Choose a **subarray** `[i, j]` and set all **occurrences of the minimum non-negative integer** in that subarray to `0`.

Return the **minimum number of operations** required to make all elements in the array `0`.


### **Example 1**

**Input:**
`nums = [0, 2]`
**Output:**
`1`
**Explanation:**
Choose `[1, 1] → [2]`, minimum = 2 → set all 2s to 0 → `[0, 0]`.


### **Example 2**

**Input:**
`nums = [3, 1, 2, 1]`
**Output:**
`3`
**Explanation:**
Each distinct value (3, 2, 1) eventually needs one operation.


### **Example 3**

**Input:**
`nums = [1, 2, 1, 2, 1, 2]`
**Output:**
`4`
**Explanation:**
Removing 1s first creates gaps (zeros), splitting the array into several subarrays before removing 2s.



##  **Intuition**

Zeros act as **boundaries** and every continuous block of nonzero numbers must be handled independently.

Inside each block, you can repeatedly:

1. Choose a subarray.
2. Zero out all elements equal to the current **minimum**.

Every time values drop, one or more “layers” are peeled off.
This pattern looks a lot like **mountain levels** each drop marks the end of one operation.

So the task reduces to counting **how many times the array height decreases** as we traverse it.



##  **Optimized Idea**
>##  **Monotonic Stack**

We can simulate the “height changes” with a **monotonic stack**.

* Maintain a stack of current non-decreasing elements.
* When we encounter a smaller number:

  * We pop from the stack, each pop = one completed operation.
* When the number is different from the top, we push it.

At the end, leftover elements in the stack each represent one unfinished operation.


```python []
class Solution:
    def minOperations(self, nums):
        stack = [0] * (len(nums) + 1)
        top = 0
        ans = 0

        for num in nums:
            while stack[top] > num:
                top -= 1
                ans += 1
            if stack[top] != num:
                top += 1
                stack[top] = num

        return ans + top
```
``` cpp []
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size();
        vector<int> stack(n + 1, 0);
        int top = 0;
        int ans = 0;

        for (int num : nums) {
            while (stack[top] > num) {
                top--;
                ans++;
            }
            if (stack[top] != num) {
                top++;
                stack[top] = num;
            }
        }

        return ans + top;
    }
};

```

##  **Dry Run**

`nums = [3, 1, 2, 1]`

| num | stack before | action                       | ans | top |
| --- | ------------ | ---------------------------- | --- | --- |
| 3   | [0]          | push 3                       | 0   | 1   |
| 1   | [0,3]        | pop 3 → ans=1 → push 1       | 1   | 1   |
| 2   | [0,1]        | push 2                       | 1   | 2   |
| 1   | [0,1,2]      | pop 2 → ans=2 → push 1(same) | 2   | 1   |

End → `ans + top = 2 + 1 = 3 ✅`

##  **Complexity Analysis**

| Type      | Complexity                                            |
| --------- | ----------------------------------------------------- |
| **Time**  | O(n)  each element is pushed and popped at most once |
| **Space** | O(n) stack storage                                  |


##  **Takeaways**

* Each *drop* in height = one operation.
* The stack tracks how many levels are currently active.
* Zeros reset context automatically since they never increase height.
* The final count (`ans + top`) gives total layers peeled thats's the true minimum number of operations.

---
