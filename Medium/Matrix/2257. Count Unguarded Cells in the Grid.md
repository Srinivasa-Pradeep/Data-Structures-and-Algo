## [Count Unguarded Cells in the Grid](https://leetcode.com/problems/count-unguarded-cells-in-the-grid/) - Notes
### ðŸ’¡ Intuition

Each guard can see in all four directions â€” up, down, left and right until blocked by a **wall** or another **guard**.
Our task is to count all **empty cells** that are **not** seen by any guard.

Since the total grid area `m * n â‰¤ 1e5`, we can directly simulate this without worrying about performance.
We just â€œsweepâ€ from every guard and mark the cells it can see.

---

### Code

```python []
class Solution:
    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:
        WALL_OR_GUARD = 1
        GUARDED = -1
        grid = [[0] * n for _ in range(m)]

        # Mark guards and walls
        for r, c in walls + guards:
            grid[r][c] = WALL_OR_GUARD

        # Sweep in 4 directions for each guard
        for r, c in guards:
            for dr, dc in [(-1,0), (1,0), (0,-1), (0,1)]:
                nr, nc = r + dr, c + dc
                while 0 <= nr < m and 0 <= nc < n and grid[nr][nc] != WALL_OR_GUARD:
                    grid[nr][nc] = GUARDED
                    nr += dr
                    nc += dc

        # Count unguarded cells
        return sum(cell == 0 for row in grid for cell in row)
```


---



### âš™ï¸ Approach

1. **Initialize the grid** with `0` for empty cells.
   Mark all guards and walls as `1` (to indicate obstacles).
2. **For each guard**, explore four directions:

   * Move step-by-step until another `1` (wall/guard) is found.
   * Mark all visible cells as `-1` (guarded).
3. **Count** how many `0`s remain â€” those are the unguarded, unoccupied cells.
---

### â±ï¸ Complexity Analysis

* **Time Complexity:** `O(m * n)`
  Each cell is processed at most once per direction â€” perfectly fine for â‰¤ 1e5 cells.
* **Space Complexity:** `O(m * n)`
  We store a single integer grid.
