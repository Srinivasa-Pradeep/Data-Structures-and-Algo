---

# 📝 Detailed Revision Notes — [Task Manager Problem](https://leetcode.com/problems/design-task-manager/description/)

---

## **1. Understanding the Problem**

We were asked to build a system that manages tasks with operations:

* `add(userId, taskId, priority)`
* `edit(taskId, newPriority)`
* `rmv(taskId)`
* `execTop() → userId`

Rules:

* Execute task with **highest priority** first.
* If two tasks have the same priority, execute the one with **smallest taskId**.
* Once executed, task is removed from the system.

So essentially:
👉 We need a **priority-based scheduling system**.

---

## **2. First Thoughts**

We brainstormed what data structures can handle this:

* **Dictionary (`dict`)**:
  To quickly check if a task is still active (O(1)).
  `task_dict[taskId] = (userId, priority)`

* **Heap (`heapq`)**:
  To always fetch the highest priority task quickly (O(log n)).
  Store tuples: `(priority, taskId, userId)`

We thought:

* Heap gives us the "candidate provider" (the best one to execute).
* Dict gives us the "truth" (whether this candidate is still valid or stale).

---

## **3. First Implementation**

We coded something like:

```python
heapq.heappush(heap, (priority, taskId, userId))
```

But Python heap is **min-heap**, so small priority comes first.
We wanted **max-heap** → so we pushed `(-priority, taskId, userId)`.

---

## **4. First Wall: Stale Entries**

Problem: When we `edit` or `rmv`, the old values still sit in the heap.

Example:

```python
tasks = [[1, 101, 10], [2, 102, 20]]
edit(102, 5)
execTop()
```

Heap: `(-20, 102, 2), (-5, 102, 2), (-10, 101, 1)`
Dict: `{101: (1,10), 102: (2,5)}`

* If we pop top: `(-20, 102, 2)` → this says priority=20.
* But dict says priority=5 → stale entry.

So without checking dict, we execute the wrong task.

---

## **5. Fix Idea: Lazy Deletion**

Instead of cleaning heap every time (expensive), we decided:

* Keep all versions in heap.
* At `execTop`, **skip stale entries**.

Algorithm at `execTop`:

1. Pop from heap.
2. If `taskId not in dict` → skip (already removed).
3. If heap’s priority doesn’t match dict’s priority → skip (stale).
4. Otherwise, valid → execute and remove from dict.

This made it correct.

---

## **6. Second Wall: Tie-breaking**

Problem: For same priority, smallest taskId should win.

Our heap ordering `( -priority, taskId )` made **smaller priority bigger** but didn’t correctly prioritize smaller taskId.

Fix:

```python
(-priority, -taskId, taskId)
```

Why?

* `-priority`: max priority first.
* `-taskId`: ensures smaller taskId wins (since -smaller > -larger).
* Keep `taskId` again at the end for dict lookup.

---

## **7. Dry Run of the Key Failing Case**

Input:

```
["TaskManager","add","edit","execTop","rmv","add","execTop"]
[[[[1,101,8],[2,102,20],[3,103,5]]],[4,104,5],[102,9],[],[101],[50,101,8],[]]
```

Step by step:

* Init → heap has (-8,-101,101), (-20,-102,102), (-5,-103,103)
* Edit(102,9) → heap now also has (-9,-102,102). Dict updates {102: (2,9)}
* ExecTop:

  * Pop (-20,-102,102). Dict says priority=9 → stale → skip.
  * Pop (-9,-102,102). Dict says 9 → valid → execute. Returns `2`.
* rmv(101) → dict removes 101.
* add(50,101,8) → heap push (-8,-101,101). Dict says {101:(50,8)}
* ExecTop:

  * Pop (-8,-101,101). Dict says user=50, priority=8 → valid. Returns `50`.

Correct output: `[null,null,null,2,null,null,50]`.

---

## **8. Final Correct Implementation**

```python
import heapq
from typing import List

class TaskManager:
    def __init__(self, tasks: List[List[int]]):
        self.task_dict = {}  # taskId -> (userId, priority)
        self.heap = []       # (-priority, -taskId, taskId)
        for userId, taskId, priority in tasks:
            self.task_dict[taskId] = (userId, priority)
            heapq.heappush(self.heap, (-priority, -taskId, taskId))
        
    def add(self, userId: int, taskId: int, priority: int) -> None:
        self.task_dict[taskId] = (userId, priority)
        heapq.heappush(self.heap, (-priority, -taskId, taskId))
    
    def edit(self, taskId: int, newPriority: int) -> None:
        userId, _ = self.task_dict[taskId]
        self.task_dict[taskId] = (userId, newPriority)
        heapq.heappush(self.heap, (-newPriority, -taskId, taskId))
        
    def rmv(self, taskId: int) -> None:
        self.task_dict.pop(taskId, None)
        
    def execTop(self) -> int:
        while self.heap:
            negPriority, negTaskId, taskId = heapq.heappop(self.heap)
            if taskId in self.task_dict:
                userId, curPriority = self.task_dict[taskId]
                if -negPriority == curPriority:
                    self.task_dict.pop(taskId)
                    return userId
        return -1
```

---

## **9. Lessons Learned**

1. Use **dict + heap together** → dict keeps truth, heap keeps candidates.
2. Handle **stale entries** with lazy deletion.
3. Tie-breaking rules need careful tuple design.
4. Dry running tricky testcases exposes hidden bugs.

---
