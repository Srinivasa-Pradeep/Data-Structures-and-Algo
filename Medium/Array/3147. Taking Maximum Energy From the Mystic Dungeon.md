# [Maximum Energy in Mystic Dungeon](https://leetcode.com/problems/taking-maximum-energy-from-the-mystic-dungeon/description/) — Notes

## Problem Summary
- You are given an array `energy` of `n` magicians.
- Each magician has an energy value (can be positive or negative).
- After absorbing energy from magician `i`, you teleport to magician `i + k`.
- This continues until `i + k` is out of bounds.
- Goal: choose a starting point to **maximize total energy** collected.

### Examples

**Example 1:**  
```python
energy = [5, 2, -10, -5, 1], k = 3
# Maximum energy = 3 (start at index 1: 2 + 1)
````

**Example 2:**

```python
energy = [-2, -3, -1], k = 2
# Maximum energy = -1 (start at index 2)
```

## Core Intuition

* Let `best[i]` = maximum energy you can collect starting from magician `i`.
* Formula:

```python
best[i] = energy[i] + best[i + k]   # if i + k < n
best[i] = energy[i]                  # if i + k >= n
```

* We compute `best[i]` **from right to left**, so `best[i + k]` is already known.
* Maximum energy = `max(best)`.

## Why Right-to-Left?

* Each `best[i]` depends on `best[i + k]` (the "future").
* If we went left-to-right, `best[i + k]` wouldn't be computed yet.
* Dynamic Programming principle: compute from base cases to dependent cases.

## Optimization Trick

* To avoid out-of-bounds checks:

```python
dp = [0] * (n + k)  # pad with extra zeros
for i in range(n - 1, -1, -1):
    dp[i] = dp[i + k] + energy[i]
max_energy = max(dp[:n])
```

* Extra `k` zeros at the end act as base cases.
* `max(dp[:n])` ensures we only consider valid starting points.

## Python Tip

* `dp = energy` → both point to same list (modifying one affects the other).
* `dp = energy[:]` → creates a copy (safe to modify independently).

## Summary Steps

1. Initialize `best` (or `dp`) array.
2. Loop from **right to left**:

   * If jump inside bounds → `best[i] = energy[i] + best[i+k]`
   * Else → `best[i] = energy[i]`
3. Return `max(best)`.



