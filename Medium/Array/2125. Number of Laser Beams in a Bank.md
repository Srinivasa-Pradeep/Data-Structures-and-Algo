### 💡 **Problem:** [Number of Laser Beams in a Bank](https://leetcode.com/problems/number-of-laser-beams-in-a-bank/description/)

**Description:**
Each string in the `bank` represents a row of security devices in a bank, where `'1'` means a device is present and `'0'` means empty space.
A laser beam can only be transmitted from one row to the next **non-empty** row.
The number of beams between two such rows is the product of the count of devices in both rows.
You need to return the total number of laser beams in the bank.

---

### 🧠 **Intuition**

Each row with devices can transmit to the next non-empty row below it.
Empty rows act as transparent gaps — no beams, but the chain continues until the next active row.
So the total beams between two valid rows = (devices in previous valid row) × (devices in current row).

---

### 🪄 **Approach**

1. Count devices in the first row and store it in `start`.
2. Loop through all subsequent rows:

   * Count devices in the current row.
   * Skip if there are none (`0`).
   * Add `devices * start` to total beams.
   * Update `start` to current device count.
3. Return the total beams.

---

### ⏱ **Complexity**

* **Time Complexity:** (O(n * m)) — each row scanned once.
* **Space Complexity:** (O(1)) — constant extra space.

---

### 🧩 **Code**

```python
from typing import List

class Solution:
    def numberOfBeams(self, bank: List[str]) -> int:       
        start = bank[0].count("1")
        laserCount = 0
        for row in bank[1:]:
            devices = row.count("1")
            if not devices:
                continue
            laserCount += devices * start
            start = devices
        return laserCount
```

---

### 🧭 **Key Learnings**

* Skip irrelevant data early — it simplifies logic and saves time.
* Multiplication patterns often appear in pairwise relationships (like devices transmitting to next rows).
* Maintaining a “previous active state” (`start`) is a clean trick to handle sequential dependencies.
* Elegant solutions usually come from thinking about **relationships** between elements, not just individual counts.

