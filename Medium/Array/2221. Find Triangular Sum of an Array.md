Perfect — let’s bundle the explanations with the code versions side by side. Here’s a nice **study note** in `.md` that you can keep:

````markdown
# Triangular Sum of Array – Notes

## Problem Recap
We’re given an array `nums` of digits (0–9).  
We repeatedly:
1. Build a new array where each element = `(nums[i] + nums[i+1]) % 10`.
2. Shrink the array by 1 each step.
3. Stop when only one element remains → that’s the **triangular sum**.

---

## Approaches

### 1. Simulation (Shrinking Array)
Straightforward simulation: actually perform the process.

```python
class Solution:
    def triangularSum(self, nums: list[int]) -> int:
        n = len(nums)
        while n > 1:
            nums = [(nums[i] + nums[i+1]) % 10 for i in range(n-1)]
            n -= 1
        return nums[0]
````

* Time Complexity: **O(n²)**
* Space Complexity: **O(n)**

Example run:

```
[1,2,3,4,5]
→ [3,5,7,9]
→ [8,2,6]
→ [0,8]
→ [8]
```

Final Answer = **8**

---

### 2. In-place Simulation

Reuse the array, avoid creating a new list every round.

```python
class Solution:
    def triangularSum(self, nums: list[int]) -> int:
        n = len(nums)
        while n > 1:
            for i in range(n-1):
                nums[i] = (nums[i] + nums[i+1]) % 10
            n -= 1
        return nums[0]
```

* Time Complexity: **O(n²)**
* Space Complexity: **O(1)**
* More memory-efficient.

---

### 3. Binomial Coefficient Trick

We can jump straight to the result using Pascal’s Triangle.
Each element `nums[i]` contributes with weight `C(n-1, i)`.

```python
class Solution:
    def triangularSum(self, nums: list[int]) -> int:
        n = len(nums)
        res = 0
        comb = 1  # C(n-1, 0)
        for i in range(n):
            res = (res + nums[i] * comb) % 10
            # update to next binomial coefficient
            comb = comb * (n-1-i) // (i+1) if i+1 < n else comb
        return res
```

Formula:

```
triangularSum = ( Σ nums[i] * C(n-1, i) ) % 10
```

* Time Complexity: **O(n)**
* Space Complexity: **O(1)**

---

## Key Learnings

* **Loop condition**: use `while n > 1` (or `while n != 1`) to stop at exactly one element.
* **Reassignment vs overwriting**:

  * Reassigning (`nums = [...]`) is safe.
  * Overwriting (`nums[i] = ...`) needs careful loop bounds.
* **Pascal’s Triangle connection**: shrinking arrays mirrors binomial expansion.
* Simulation is **clear and safe**; binomial is **optimized math shortcut**.

---

```

Do you want me to also **sketch a small Pascal triangle block** in the notes to make the binomial connection more intuitive?
```

