# [Triangle](https://leetcode.com/problems/triangle/description/) – Key Learnings

## Problem
Given a triangle (list of lists), find the minimum path sum from top to bottom.  
Rule: From element at `triangle[r][c]`, you may move to `triangle[r+1][c]` or `triangle[r+1][c+1]`.

---

## Naive Approach
- Pick minimum from each row → ❌ Wrong (ignores adjacency rule).

---

## Correct Approaches

### 1. Bottom-Up Dynamic Programming (in-place)
- Start from the **second-last row**.
- For each element:
```

triangle[r][c] += min(triangle[r+1][c], triangle[r+1][c+1])

````
- Answer will be in `triangle[0][0]`.
- Time: **O(n²)**  
- Space: **O(1)** (modifies input).

---

### 2. Bottom-Up DP with 1D Array (Cleanest)
```python
dp = [0] * (len(triangle) + 1)

for row in triangle[::-1]:
  for i, n in enumerate(row):
      dp[i] = min(dp[i], dp[i+1]) + n

return dp[0]
````

* `+1` in `dp` avoids index errors when checking `dp[i+1]`.
* `enumerate(row)` gives both index `i` and value `n`.
* Efficient, no input modification.
* Time: **O(n²)**
* Space: **O(n)**

---

## Complexity

* Total elements in triangle: `n(n+1)/2 ≈ O(n²)`.
* So **O(n²) time is unavoidable**.
* Optimizations focus on **space**:

  * Memoization: O(n²) space
  * In-place bottom-up: O(1) space
  * 1D DP: O(n) space

---
## Key Learnings
- Instead of using a full 2D DP table (`O(n²)` space), we can optimize to a 1D array (`O(n)` space).
- Iterate from the second-last row upwards:
  - For each element, update it as the element + min of its two children.
- Final answer will be at `dp[0]`.



## Why `len(triangle) + 1`?

* Extra space helps avoid **index out of range** when checking `dp[i + 1]`.
* It acts as a "buffer" for the last element in each row.

## Example Walkthrough

Triangle:

```
    2
   3 4
  6 5 7
 4 1 8 3
```

Steps:

* Start from `[4,1,8,3]` → dp = [4,1,8,3,0]
* Process `[6,5,7]` → dp = [7,6,10,3,0]
* Process `[3,4]`   → dp = [9,10,10,3,0]
* Process `[2]`     → dp = [11,10,10,3,0]
* Answer = dp[0] = **11**

---

## Mental Model

1. Always slow down and read constraints carefully.
2. Think row-by-row: “If I stand here, what’s the cheapest way down?”
3. Spot overlapping subproblems → classic DP.
4. Work bottom-up to reuse results efficiently.
5. `enumerate` = (index, value).
6. `len(triangle) + 1` = padding trick for safe indexing.

```


