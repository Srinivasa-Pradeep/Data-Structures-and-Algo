### [Ones and Zeroes](https://leetcode.com/problems/ones-and-zeroes/description/) - Notes

You’re given:

* An array of binary strings `strs`
* Two integers `m` and `n`

You need to find the **maximum size of a subset** of `strs` such that:

* The total number of `'0'`s used ≤ `m`
* The total number of `'1'`s used ≤ `n`

Each string can either be **chosen** or **not chosen**, and each choice consumes a certain count of `0`s and `1`s.

In short you’re filling a limited “bag” (of `m` zeros and `n` ones) with as many strings as possible.



### **Example 1**

**Input:**

```
strs = ["10", "0001", "111001", "1", "0"]
m = 5, n = 3
```

**Output:**

`
4
`

**Explanation:**

The largest subset is:

`
{"10", "0001", "1", "0"}
`

This subset uses `5 zeros` and `3 ones`  exactly within the limits.
Total strings chosen = **4 ✅**



### **Example 2**

**Input:**

```
strs = ["10", "0", "1"]
m = 1, n = 1
```

**Output:**

`
2
`

**Explanation:**

Subset `{ "0", "1" }` uses one zero and one one → total **2 strings**.



### **Constraints**

```
1 ≤ strs.length ≤ 600
1 ≤ strs[i].length ≤ 100
1 ≤ m, n ≤ 100
```

## **Naive Thinking (Before the Real Insight)**

At first glance, we might think:

> “Just try all possible subsets and check which one fits within `m` zeros and `n` ones.”

But there’s a catch, the number of subsets grows **exponentially** (`2^len(strs)`),
and with 600 strings, that’s far beyond feasible.

We need something smarter, something that **remembers** previous combinations efficiently.



## **Optimized Solution**

> ### **Key Idea**

Each string can be thought of as an *item* with:

* `cost_0 = number of '0's`
* `cost_1 = number of '1's`
* `value = 1` (since adding it increases subset size by 1)

We must choose a subset that **maximizes total value** without exceeding `m` or `n`.

That’s a **2D 0/1 Knapsack Problem**.

But instead of using a full 2D array `dp[m+1][n+1]`,
we use a **hashmap** to store only *reachable states* making it cleaner and memory efficient.



## **Algorithm Walkthrough**

We maintain a dictionary `dp`:

```
dp[(zeros_used, ones_used)] = max subset size achievable
```

Start with:

```
dp = {(0, 0): 0}  # Using 0 zeros and 0 ones → subset size 0
```

Then, for every string `s`:

1. Count its `zeroes` and `ones`.
2. For every existing `(used_zeros, used_ones)` in `dp`,
   try adding this string to form a new state `(used_zeros + zeroes, used_ones + ones)`.
3. If it stays within limits, record the new subset size.
4. Merge these new states into `dp`.





```python []
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        dp = {(0, 0): 0}

        for s in strs:
            ones = s.count('1')
            zeroes = s.count('0')
            newdp = {}

            for (prevZeroes, prevOnes), val in dp.items():
                newZeroes, newOnes = prevZeroes + zeroes, prevOnes + ones
                if newZeroes <= m and newOnes <= n:
                    if (newZeroes, newOnes) not in dp or dp[(newZeroes, newOnes)] < val + 1:
                        newdp[(newZeroes, newOnes)] = val + 1

            dp.update(newdp)

        return max(dp.values())
```
``` cpp []
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        map<pair<int, int>, int> dp;
        dp[{0, 0}] = 0;

        for (auto &s : strs) {
            int zeros = 0, ones = 0;
            for (char c : s) {
                if (c == '0') zeros++;
                else ones++;
            }

            map<pair<int, int>, int> newdp;

            for (auto &[state, val] : dp) {
                int used0 = state.first + zeros;
                int used1 = state.second + ones;

                if (used0 <= m && used1 <= n) {
                    if (!dp.count({used0, used1}) || dp[{used0, used1}] < val + 1) {
                        newdp[{used0, used1}] = val + 1;
                    }
                }
            }

            for (auto &[state, val] : newdp) {
                dp[state] = max(dp[state], val);
            }
        }

        int ans = 0;
        for (auto &[_, val] : dp) ans = max(ans, val);
        return ans;
    }
};

```

---

## **How It Works**
Let’s trace the first example:

```
strs = ["10", "0001", "111001", "1", "0"]
m = 5, n = 3
```

###  Start:

```
dp = {(0,0): 0}
```

###  Process "10"

* 1 zero, 1 one → fits easily.

```
dp = {(0,0):0, (1,1):1}
```

###  Process "0001"

* 3 zeros, 1 one
* Try to add it to existing states:

```
(0,0) → (3,1) => 1
(1,1) → (4,2) => 2
```

Now `dp` expands to include:

```
{(0,0):0, (1,1):1, (3,1):1, (4,2):2}
```

**Continue this for all strings…**

Eventually, the best we can form uses **5 zeros and 3 ones** for a total of **4 strings**.



## **Complexity Analysis**

| Step                          | Time                      | Space    |
| ----------------------------- | ------------------------- | -------- |
| Iterating through all strings | O(len(strs) × m × n)      | O(m × n) |
| Sparse storage via dict       | ~Much smaller in practice | —        |

Even for the max constraints (`m = 100, n = 100, strs = 600`),
this runs comfortably.



## **Why This Works**

* The hashmap keeps track only of **valid reachable combinations** not the whole grid.
* For each string, we consider adding it **once** (0/1 constraint).
* We iterate backwards implicitly through the state-space, ensuring no string is reused.
* This turns a huge DP table into a compact and efficient state tracker.



## **Takeaways**

* This problem is a **beautiful 2D Knapsack** in disguise.
* You don’t always need a giant matrix  a dictionary can encode state transitions neatly.
* “Knapsack” doesn’t always mean “weights”  sometimes it’s just *limits on features*.

---

### **In One Line**

> “We pack zeros and ones like weights in a two-dimensional knapsack  but only the clever ones fit.”



