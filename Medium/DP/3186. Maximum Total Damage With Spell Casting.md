# [Magician Spell Maximum Damage](https://leetcode.com/problems/maximum-total-damage-with-spell-casting/description/) — Intuition & Approach

## Problem Statement
- You are given an array `power` of spell damages.  
- Rule: if you pick a spell with damage `x`, you **cannot pick** spells with damage `x-2`, `x-1`, `x+1`, `x+2`.  
- Each spell can be cast **only once**.  
- Goal: **maximize total damage**.

---

## Step 1: Count total damage per spell
- Group same damage values:  
  ```python
  from collections import Counter
  power = [1,1,3,4]
  dist = Counter(power)  # {1:2, 3:1, 4:1}
  points = {num: num*count for num, count in dist.items()}  # total damage per number
  ````
Example:

  ```
  1 → 2 (two spells of 1)
  3 → 3 (one spell of 3)
  4 → 4 (one spell of 4)
  ```

---

## Step 2: Visualize on a number line

* Sort unique damage values: `nums = sorted(points.keys())`
* Mark total damage below each number:

  ```
  1(2)    3(3)    4(4)
  ```
* Draw conflicts (numbers ±1 or ±2 from each number).
* Goal: **pick numbers to maximize total damage while respecting conflicts**.

---

## Step 3: Build intuition like a game

* Pick a number → block neighbors
* Skip a number → carry max total damage so far
* Example `[1,1,3,4]`:

  1. Pick 1 → total = 2 → blocks 3
  2. Pick 4 → total = 2 + 4 = 6 → cannot pick 3 (already blocked)
* Maximum damage = 6 ✅

---

## Step 4: Dynamic Programming Approach

* Let `nums` = sorted unique numbers
* Let `dp[i]` = max damage using numbers up to `nums[i]`
* For each `i`:

  ```python
  take = points[nums[i]] + dp[j]  # j is the largest index with nums[j] <= nums[i]-3
  skip = dp[i-1] if i > 0 else 0
  dp[i] = max(take, skip)
  ```
* Result = `dp[-1]`

---
## Python Code — Maximum Spell Damage

```python
from collections import Counter

def maximumTotalDamage(power):
    # Step 1: Count total damage per unique spell
    dist = Counter(power)
    points = {num: num*count for num, count in dist.items()}
    
    # Step 2: Sort unique numbers
    nums = sorted(points.keys())
    
    # Step 3: Initialize DP array
    dp = [0] * len(nums)
    
    for i in range(len(nums)):
        # Pick nums[i]
        take = points[nums[i]]
        j = i - 1
        # Skip numbers within distance 2
        while j >= 0 and nums[i] - nums[j] <= 2:
            j -= 1
        if j >= 0:
            take += dp[j]
        
        # Skip nums[i]
        skip = dp[i-1] if i > 0 else 0
        
        dp[i] = max(take, skip)
    
    return dp[-1]

# Example usage
power = [1,1,3,4]
print(maximumTotalDamage(power))  # Output: 6

power = [7,1,6,6]
print(maximumTotalDamage(power))  # Output: 13
```
---

## Step 5: Mental Shortcut / Visualization

* Think of it as a “number line game”: pick numbers strategically
* Two numbers can be picked if **distance ≥ 3**
* Group repeats → sum total damage per number
* Use DP to remember the best choice so far

---

### Key Takeaways

1. Group repeated numbers → reduces problem size.
2. Think in terms of **total damage per unique number**.
3. Visualize numbers on a **line** → see which are blocked.
4. Use **DP** to systematically find maximum total damage.
5. Manual examples first → intuition → code.

```


