# [Pacific Atlantic Water Flow]() — Notes

### 🔹 Problem

You’re given a grid `heights[m][n]` representing heights above sea level.

* **Pacific Ocean** touches the **top** and **left** edges.
* **Atlantic Ocean** touches the **bottom** and **right** edges.
  Water can flow **downhill or flat** to 4 neighboring cells (N, S, E, W).
  Find all cells from which water can flow to **both** oceans.

---

### 🔹 Key Intuition

Instead of starting from every cell and checking if water *can reach* both oceans (which would be slow),
**reverse the perspective** — start from the **oceans** themselves.

From each ocean:

* Flow **inward**, moving only to cells that are **higher or equal** in height.
* This way, you mark all cells that can “drain” into that ocean.

The intersection of Pacific’s reach and Atlantic’s reach gives the final result.

---

### 🔹 Algorithm Steps

1. **Initialize**

   * Let `m, n = len(heights), len(heights[0])`.
   * Create two sets: `pacific` and `atlantic`.

2. **Define directions**

   ```python
   directions = [(1,0), (-1,0), (0,1), (0,-1)]
   ```

3. **DFS function**

   * Mark current cell as visited.
   * From `(r, c)`, explore neighbors `(nr, nc)` if:

     * It’s inside grid bounds.
     * Not already visited.
     * `heights[nr][nc] >= heights[r][c]` (can move “uphill”).
   * Continue recursively.

4. **Start from ocean edges**

   * Pacific → top row + left column.
   * Atlantic → bottom row + right column.
   * Run DFS from all these border cells.

5. **Intersection**

   * Return cells that exist in both `pacific` and `atlantic` sets.

---

### 🔹 Code

```python
class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        if not heights or not heights[0]:
            return []
        
        m, n = len(heights), len(heights[0])
        pacific, atlantic = set(), set()
        directions = [(1,0), (-1,0), (0,1), (0,-1)]

        def dfs(r, c, visited):
            visited.add((r, c))
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                if (0 <= nr < m and 0 <= nc < n and
                    (nr, nc) not in visited and
                    heights[nr][nc] >= heights[r][c]):
                    dfs(nr, nc, visited)

        for c in range(n):
            dfs(0, c, pacific)
            dfs(m - 1, c, atlantic)
        for r in range(m):
            dfs(r, 0, pacific)
            dfs(r, n - 1, atlantic)

        return list(pacific & atlantic)
```

---

### 🔹 Complexity

* **Time:** `O(m * n)` — each cell visited at most twice.
* **Space:** `O(m * n)` — recursion + visited sets.

---

### 🔹 Key Takeaways

* Flip the problem: start *from* the oceans, not *toward* them.
* “Can move uphill” condition (`next >= curr`) is the reversal trick.
* Two simultaneous DFS/BFS traversals + intersection = elegant and optimal.

