### [Power Grid Maintenance](https://leetcode.com/problems/power-grid-maintenance/description/) - Notes

Problem Recap

Youâ€™re given:

c power stations numbered 1..c

A list of bidirectional connections between them
â†’ connected stations form a power grid.

A list of queries of two types:

1. [1, x]: Perform a maintenance check on station x


2. [2, x]: Turn station x offline




Rules for maintenance:

1. If x is online â†’ the check is resolved by x itself.


2. If x is offline â†’ itâ€™s handled by the smallest online station ID in the same grid.


3. If no online station exists â†’ return -1.



Return an array with the results of all [1, x] queries.


---

Example

Input:

c = 5
connections = [[1,2],[2,3],[3,4],[4,5]]
queries = [[1,3],[2,1],[1,1],[2,2],[1,2]]

Output:

[3, 2, 3]

Explanation:

All stations start online â†’ one big grid {1,2,3,4,5}

[1,3] â†’ station 3 online â†’ answer = 3

[2,1] â†’ 1 goes offline

[1,1] â†’ 1 offline â†’ smallest online in grid = 2

[2,2] â†’ 2 goes offline

[1,2] â†’ 2 offline â†’ next online = 3



---

Naive Approach (Brute Force)

For each query [1, x]:

1. Find all stations connected to x (via DFS/BFS).


2. Among them, pick the smallest online ID.


3. Mark stations offline when [2, x] appears.



def processQueries(c, connections, queries):
    # Adjacency list
    graph = defaultdict(list)
    for u, v in connections:
        graph[u].append(v)
        graph[v].append(u)

    online = [True] * (c + 1)
    res = []

    def dfs(x, visited):
        visited.add(x)
        for nei in graph[x]:
            if nei not in visited:
                dfs(nei, visited)

    for t, x in queries:
        if t == 1:
            if online[x]:
                res.append(x)
            else:
                visited = set()
                dfs(x, visited)
                online_nodes = [n for n in visited if online[n]]
                res.append(min(online_nodes) if online_nodes else -1)
        else:
            online[x] = False
    return res

Complexity

Each [1, x] query may traverse the whole grid â†’ O(N + E)

Too slow for 10âµ stations.



---

Optimized Idea

> (Union-Find + Linked Traversal)



Observations:

Connectivity never changes â†’ use Disjoint Set Union (DSU) to pre-group stations.

Once offline, a station never comes back.

Each component only needs to know its smallest online station.


Trick:
We can arrange every componentâ€™s members in sorted order once,
then use simple pointers to skip offline nodes on demand.


---

Intuition

For each DSU component:

Keep:

comp_min[root] â†’ smallest currently online station in that component.

next_node[i] â†’ next station (by ID) in same component.



When a station x goes offline:

If x equals comp_min[root], move the pointer forward until we find an online one.


This way, each station is â€œskippedâ€ at most once â†’ near-linear time overall.


---

Clean Code

from typing import List

class Solution:
    def processQueries(self, c: int, connections: List[List[int]], queries: List[List[int]]) -> List[int]:
        parent = list(range(c + 1))

        def find(x):
            while parent[x] != x:
                parent[x] = parent[parent[x]]
                x = parent[x]
            return x

        # Step 1: union connected stations
        for a, b in connections:
            ra, rb = find(a), find(b)
            if ra != rb:
                parent[rb] = ra

        # Step 2: link nodes in sorted order within each component
        next_node = [0] * (c + 1)
        comp_min = [0] * (c + 1)
        last = {}

        for i in range(1, c + 1):
            r = find(i)
            if comp_min[r] == 0:
                comp_min[r] = i
            else:
                next_node[last[r]] = i
            last[r] = i

        offline = [False] * (c + 1)
        res = []

        # Step 3: process queries
        for t, x in queries:
            if t == 1:  # maintenance check
                if not offline[x]:
                    res.append(x)
                else:
                    r = find(x)
                    res.append(comp_min[r] if comp_min[r] else -1)
            else:  # t == 2 â†’ turn off station
                if not offline[x]:
                    offline[x] = True
                    r = find(x)
                    if comp_min[r] == x:
                        y = next_node[x]
                        while y and offline[y]:
                            y = next_node[y]
                        comp_min[r] = y if y else 0

        return res


---

Complexity

Step	Time	Space

Build DSU	O(N)	O(N)
Build linked order	O(N)	O(N)
Process Queries	O(Q) amortized	O(N)
Total	O(N + Q)	O(N)


Each node is walked past at most once during pointer advancement â†’ effectively linear.


---

Example Revisited

Input

c = 3
connections = []
queries = [[1,1],[2,1],[1,1]]

Walkthrough

1. [1,1] â†’ 1 online â†’ answer = 1


2. [2,1] â†’ 1 offline


3. [1,1] â†’ 1 offline, no online node â†’ -1



Output: [1, -1]


---

Takeaways

DSU simplifies static connectivity.

When nodes only deactivate, lazy pointer updates beat complex data structures.

The smallest ideas â€” linking and skipping â€” can replace heaps, sets, or sorts.



---

> âš¡ In short:
Donâ€™t overcomplicate the grid.
Each component already knows its smallest beating heart â€”
we just listen, then move to the next when it goes silent. ğŸ¤