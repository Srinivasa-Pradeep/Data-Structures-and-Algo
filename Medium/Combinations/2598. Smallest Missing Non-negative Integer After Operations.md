## Smallest Missing Non-negative Integer After Operations - Notes

### üí° Idea

We can add or subtract `value` any number of times to elements of `nums`.
After all operations, the **remainder (num % value)** of each element **never changes**.
So, we only care about how many elements fall into each remainder group.

The **MEX** depends on how many full ‚Äúrounds‚Äù of numbers (from 0 upward)
we can build using these remainder counts.

---

## ‚öôÔ∏è Step-by-step logic

### 1Ô∏è‚É£ Build remainder frequencies

For each number:

```python
freq[num % value] += 1
```

Example:

```
nums = [1, -10, 7, 13, 6, 8]
value = 5
remainders ‚Üí [1, 0, 2, 3, 1, 3]
freq = [1, 2, 1, 2, 0]
# remainder: 0  1  2  3  4
```

---

### 2Ô∏è‚É£ Find how many full ‚Äúrounds‚Äù we can form

Each full round = one complete set of remainders `[0, 1, 2, ‚Ä¶, value-1]`.

```python
maxround = min(freq)
```

* `min(freq)` tells how many *complete rounds* we can build.
* Every full round gives `value` more consecutive numbers we can form.

---

### 3Ô∏è‚É£ Remove those full rounds

We remove one of each remainder per round:

```python
freq = [item - maxround for item in freq]
```

---

### 4Ô∏è‚É£ Handle next partial round

If we can‚Äôt even make remainder `0`, stop:

```python
if freq[0] == 0:
    return maxround * value
```

Otherwise, count how far we can go before hitting a remainder with `0` count.

```python
ind = 0
while ind+1 < value and freq[ind+1] > 0:
    ind += 1
```

---

### 5Ô∏è‚É£ Combine both parts

Final answer:

```python
MEX = maxround * value + ind + 1
```

---

## üß© Example 1

```
nums = [1, -10, 7, 13, 6, 8]
value = 5
freq = [1, 2, 1, 2, 0]
maxround = 0
# partial round progress:
remainders usable = 0, 1, 2, 3
‚Üí stop at remainder 4
MEX = 0*5 + 3 + 1 = 4
‚úÖ Output: 4
```

---

## üß© Example 2

```
nums = [1, -10, 7, 13, 6, 8]
value = 7
remainders = [1, 4, 0, 6, 6, 1]
freq = [1, 2, 0, 0, 1, 2, 0]
maxround = 0
# partial progress:
remainders usable = 0, 1 ‚Üí stop at 2
MEX = 0*7 + 1 + 1 = 2
‚úÖ Output: 2
```

---

## üß© Code (optimized)

```python
class Solution:
    def findSmallestInteger(self, nums: List[int], value: int) -> int:
        n = len(nums)
        if value == 1:
            return n
        freq = [0]*value
        for item in nums:
            freq[item % value] += 1
        maxround = min(freq)
        freq = [item - maxround for item in freq]
        if freq[0] == 0:
            return maxround * value
        ind = 0
        while ind+1 < value and freq[ind+1] > 0:
            ind += 1
        return maxround * value + ind + 1
```

---

### üß† Intuition Recap

* Each remainder class can ‚Äúproduce‚Äù infinite numbers spaced by `value`.
* MEX = total full rounds * value + first missing remainder index.
* Super clean and efficient (O(n + value)).

