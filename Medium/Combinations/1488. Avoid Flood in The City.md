Perfect da 🤍 here’s the **complete clean note** — everything from explanation → dry-run → code (both simple & optimized).
It’s written like your personal LeetCode journal entry so you can store it directly in your notes repo 💻

---

# 🌧️ Avoid Flood in The City — Complete Notes

## 🔍 Problem Understanding

We have a list `rains`, where:

* `rains[i] > 0` → it rains over lake `rains[i]`
* `rains[i] == 0` → it’s a **dry day**, we can **choose one lake to dry**

We must **prevent any lake from flooding**, i.e. no lake should be rained on twice without being dried in between.

**Goal:**
Return an array `res` of the same length where:

* `-1` → for rain days
* `{lake_number}` → for dry days indicating which lake we dry
  If it’s impossible to avoid flooding → return `[]`

---

## 💡 Intuition

We can’t control which day it rains.
We can only control which lake to dry on `0` days.

So when a lake rains again, it must have been dried **after its last rain** and **before today**.

That means:

* Keep track of the **last day** each lake got filled.
* Keep track of all **available dry days**.
* Whenever a lake rains again:

  * Find a dry day **after** its last rain.
  * Assign that dry day to dry the lake.
  * If none → flood → return `[]`.

---

## 🧠 Step-by-Step Algorithm

### Variables

* `h`: `{lake: last_rain_day}`
* `q`: queue/list of available dry day indices
* `res`: result list of length `n`

---

### Logic

#### For each day `i`, lake `x` in `rains`:

1. If `x > 0` (rain day):

   * If `x` already in `h` (means lake full):

     * Find a dry day `j` in `q` such that `j > h[x]`.
     * Assign `res[j] = x` (dry that lake on day `j`).
     * Remove `j` from `q`.
     * If not found → return `[]` (flood).
   * Append `-1` to `res`.
   * Update `h[x] = i`.

2. If `x == 0` (dry day):

   * Append `1` to `res` as placeholder.
   * Add `i` to `q`.

---

## 🧩 Example Walkthrough

Input:
`rains = [1, 2, 0, 2, 3, 0, 1]`

| Day | rains[i] | Action                                             | h (last_rain)   | q (dry_days) | res                        |
| --- | -------- | -------------------------------------------------- | --------------- | ------------ | -------------------------- |
| 0   | 1        | Lake 1 rains                                       | {1:0}           | []           | [-1]                       |
| 1   | 2        | Lake 2 rains                                       | {1:0, 2:1}      | []           | [-1, -1]                   |
| 2   | 0        | Dry day                                            | {1:0, 2:1}      | [2]          | [-1, -1, 1]                |
| 3   | 2        | Lake 2 rains again → dry 2 after day 1 → use day 2 | {1:0, 2:3}      | []           | [-1, -1, 2, -1]            |
| 4   | 3        | Lake 3 rains                                       | {1:0, 2:3, 3:4} | []           | [-1, -1, 2, -1, -1]        |
| 5   | 0        | Dry day                                            | {1:0, 2:3, 3:4} | [5]          | [-1, -1, 2, -1, -1, 1]     |
| 6   | 1        | Lake 1 rains again → dry 1 after day 0 → use day 5 | {1:6, 2:3, 3:4} | []           | [-1, -1, 2, -1, -1, 1, -1] |

✅ Output:
`[-1, -1, 2, -1, -1, 1, -1]`

---

## 🧩 Code 

```python
from collections import deque

class Solution:
    def avoidFlood(self, rains: List[int]) -> List[int]:
        h = {}             # lake -> last rain day
        q = deque([])      # available dry days
        res = []
        
        for i, x in enumerate(rains):
            if x:  # raining day
                if x in h:
                    for j in q:
                        if j > h[x]:      # dry day after last rain
                            res[j] = x    # dry that lake
                            q.remove(j)
                            break
                    else:
                        return []         # flood
                res.append(-1)
                h[x] = i
            else:
                res.append(1)  # placeholder
                q.append(i)
        
        return res
```

### 🕒 Complexity

| Type  | Complexity                   |
| ----- | ---------------------------- |
| Time  | O(n²) (inner loop through q) |
| Space | O(n)                         |

---

## ⚡ Optimized Version (O(n log n))

We can optimize by using **binary search** on dry days (`bisect`) instead of looping through `q`.

```python
import bisect

class Solution:
    def avoidFlood(self, rains: List[int]) -> List[int]:
        n = len(rains)
        res = [-1] * n
        full = {}       # lake -> last filled day
        dry_days = []   # sorted indices of available dry days
        
        for i, lake in enumerate(rains):
            if lake == 0:
                res[i] = 1
                bisect.insort(dry_days, i)
            else:
                if lake in full:
                    last_rain = full[lake]
                    # Find dry day > last_rain
                    idx = bisect.bisect_right(dry_days, last_rain)
                    if idx == len(dry_days):
                        return []  # no valid dry day
                    dry_day = dry_days.pop(idx)
                    res[dry_day] = lake
                full[lake] = i
        return res
```

### 🧠 Complexity

| Type  | Complexity                 |
| ----- | -------------------------- |
| Time  | O(n log n) (binary search) |
| Space | O(n)                       |

---

## 💎 Key Takeaways

* Always **track last filled day** of each lake.
* Use **dry days** smartly to prevent flood.
* **Greedy approach:** dry the lake that’s going to flood soonest.
* Optimized version uses **binary search** to quickly find the correct dry day.



