# [Find the Minimum Amount of Time to Brew Potions](https://leetcode.com/problems/find-the-minimum-amount-of-time-to-brew-potions/description/) - Notes

### **Problem Description**

You are given two integer arrays:

* `skill` → skill level of each wizard (length `n`)
* `mana` → mana capacity of each potion (length `m`)

There are `n` wizards and `m` potions.
Each potion **must pass through all wizards sequentially** in the same order.

* Time taken by the `i-th` wizard on the `j-th` potion:
  [
  time_{ij} = skill[i] \times mana[j]
  ]

* A potion can be passed to the next wizard **only when the current wizard finishes it**.

* The process must be **fully synchronized**, i.e., every wizard starts on a potion **exactly when it arrives**.

You need to **return the minimum total time** required for all potions to be brewed properly.

---


## Approach

1. **First Potion**

   * Brewing starts at **time 0**.
   * Time for each wizard to brew is fixed and straightforward to calculate.

2. **Subsequent Potions**

   * Start times are **not immediately clear**.
   * Temporarily allow the j-th potion to be brewed **non-continuously**, while the first j−1 potions require continuity.
   * Let `times[i][j]` denote the completion time for wizard `i` brewing potion `j`.

   Formula:
   [
   times[i][j] = \max(times[i-1][j], , times[i][j-1]) + skill[i] \times mana[j]
   ]

3. **Backward Update**

   * After recursion, `times[n-1][j]` gives the completion time of the j-th potion.
   * Traverse **backwards** to update completion times for previous wizards, removing gaps from temporary non-continuous allowance.

4. **Optimization**

   * `times` can be **reduced to a one-dimensional array** to save space.

---

## Implementation

```python
from typing import List

class Solution:
    def minTime(self, skill: List[int], mana: List[int]) -> int:
        n, m = len(skill), len(mana)
        times = [0] * n
        for j in range(m):
            cur_time = 0
            # Forward pass: compute times for all wizards for current potion
            for i in range(n):
                cur_time = max(cur_time, times[i]) + skill[i] * mana[j]
            times[n - 1] = cur_time
            # Backward pass: adjust times for previous wizards
            for i in range(n - 2, -1, -1):
                times[i] = times[i + 1] - skill[i + 1] * mana[j]
        return times[n - 1]
```

---

## Key Takeaways

* **Forward pass:** ensures each wizard starts after the previous wizard and after finishing prior potions.
* **Backward pass:** removes any artificial gaps introduced in the forward pass for previous wizards.
* **Dynamic programming optimization:** reduces **2D DP array to 1D**, saving space.
* **Time Complexity:** (O(nm))
* **Space Complexity:** (O(n))

---

## Complexity Analysis

* **Time Complexity:** (O(nm))

  * Dynamic programming iterates through **all wizards and potions**.

* **Space Complexity:** (O(n))

  * One-dimensional array stores intermediate completion times.






