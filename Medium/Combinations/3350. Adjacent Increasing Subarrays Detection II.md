# [Find Maximum k for Two Adjacent Increasing Subarrays](https://leetcode.com/problems/adjacent-increasing-subarrays-detection-ii/description/) - Notes

### Description

You are given an integer array `nums` of length `n` and an integer `k`.
You need to determine whether there exist **two adjacent subarrays** of length `k` that are **strictly increasing**.

That is, find indices `a` and `b` (`a < b`) such that:

* Both subarrays `nums[a..a + k - 1]` and `nums[b..b + k - 1]` are strictly increasing.
* The subarrays are **adjacent**, meaning `b = a + k`.

Return `True` if it’s possible to find such subarrays, otherwise `False`.

---

### 🔍 Example 1

**Input:**
`nums = [2,5,7,8,9,2,3,4,3,1], k = 3`
**Output:**
`true`

**Explanation:**

* Subarray starting at index `2`: `[7, 8, 9]` → strictly increasing
* Subarray starting at index `5`: `[2, 3, 4]` → strictly increasing
* These two subarrays are adjacent (`5 = 2 + 3`), hence result is **true**.

---

### 🔍 Example 2

**Input:**
`nums = [1,2,3,4,4,4,4,5,6,7], k = 5`
**Output:**
`false`

---

### ⚙️ Constraints

* `2 <= nums.length <= 100`
* `1 < 2 * k <= nums.length`
* `-1000 <= nums[i] <= 1000`

---

### 🧠 Intuition

The problem is about tracking **increasing sequences** and checking if there are **two consecutive runs** that are long enough to form two adjacent subarrays of size `k`.

We calculate the lengths of continuous increasing segments (`cur_inc_len`), compare them with the previous one (`last_inc_len`), and check if together they can form the required pair.

---

### 💻 Code

```python
class Solution:
    def maxIncreasingSubarrays(self, nums: List[int]) -> int:
        last_inc_len = 1
        cur_inc_len = 1
        ans = 1

        last = nums[0]
        for n in nums:
            if n > last:
                cur_inc_len += 1
            else:
                ans = max(ans, min(last_inc_len, cur_inc_len), cur_inc_len // 2)
                last_inc_len = cur_inc_len
                cur_inc_len = 1
            last = n
        return max(ans, min(last_inc_len, cur_inc_len), cur_inc_len // 2)
```

---

Do you want me to include a **step-by-step dry run example** (like how the lengths change for the first input)? It’ll make the logic stick when revising.


---

## ⏱️ **Complexity**

| Type      | Complexity                                     |
| --------- | ---------------------------------------------- |
| **Time**  | `O(n)` — one linear pass to find segments      |
| **Space** | `O(1)` or `O(#segments)` — small extra storage |

---

## 🧩 Example Dry Run

**nums = [2, 5, 7, 8, 9, 2, 3, 4, 3, 1]**

→ Increasing segments:
`[2,5,7,8,9]` (length = 5)
`[2,3,4]` (length = 3)
`[3]` (length = 1)

→ Pairs:
`(5, 3)` → min = 3
`(3, 1)` → min = 1
→ max k = **3**

✅ Output = 3

---

## 🗝️ Key Takeaways

* Adjacent strictly increasing subarrays → come from **consecutive increasing runs**.
* The maximum k is the **minimum length of two neighboring runs**.
* Clean linear-time solution by **grouping streaks** instead of sliding every window.


