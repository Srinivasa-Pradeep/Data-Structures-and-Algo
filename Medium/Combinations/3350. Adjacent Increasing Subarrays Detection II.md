# [Find Maximum k for Two Adjacent Increasing Subarrays](https://leetcode.com/problems/adjacent-increasing-subarrays-detection-ii/description/) - Notes

### **Problem Summary**

Given an array `nums` of n integers, find the **largest integer k** such that there exist **two adjacent subarrays** of length k that are both **strictly increasing**.
Formally, two subarrays `nums[a..a+k-1]` and `nums[b..b+k-1]` must satisfy:

* `b = a + k` (→ adjacent)
* Both are strictly increasing

Return the **maximum possible k**.

---

## 🌱 Intuition

If we can find **long increasing runs**, we just need to check **how large k** can be so that two increasing runs of length ≥ k appear **back-to-back**.

Think of the array as **streaks of increasing elements**.
The longest k you can use is limited by the **shorter** of the two adjacent increasing streaks.

So:

> Find all strictly increasing stretches and look for **two consecutive ones** whose lengths allow adjacent windows of size k.

---

## 🧩 Step-by-Step Reasoning

1. **Compute increasing lengths**

   * For every index `i`, compute `inc[i]` = length of the current increasing run ending at `i`.
   * Or equivalently, walk through and count how long the current strictly increasing segment is.

2. **Find consecutive increasing segments**

   * Break the array into segments where each is strictly increasing.
   * Store their lengths: `segments = [len1, len2, len3, ...]`.

3. **Compute possible k**

   * For every **adjacent pair** of segments,
     the possible `k` is `min(len1, len2)` (the shorter one limits both).
   * Take the **maximum** over all such pairs.

---

## ⚙️ Optimal Code (O(n))

```python
class Solution:
    def maxIncreasingSubarrays(self, nums):
        n = len(nums)
        segments = []
        length = 1

        # Step 1: collect lengths of increasing segments
        for i in range(1, n):
            if nums[i] > nums[i - 1]:
                length += 1
            else:
                segments.append(length)
                length = 1
        segments.append(length)

        # Step 2: check adjacent segments
        ans = 0
        for i in range(1, len(segments)):
            ans = max(ans, min(segments[i - 1], segments[i]))

        return ans
```

---

## ⏱️ **Complexity**

| Type      | Complexity                                     |
| --------- | ---------------------------------------------- |
| **Time**  | `O(n)` — one linear pass to find segments      |
| **Space** | `O(1)` or `O(#segments)` — small extra storage |

---

## 🧩 Example Dry Run

**nums = [2, 5, 7, 8, 9, 2, 3, 4, 3, 1]**

→ Increasing segments:
`[2,5,7,8,9]` (length = 5)
`[2,3,4]` (length = 3)
`[3]` (length = 1)

→ Pairs:
`(5, 3)` → min = 3
`(3, 1)` → min = 1
→ max k = **3**

✅ Output = 3

---

## 🗝️ Key Takeaways

* Adjacent strictly increasing subarrays → come from **consecutive increasing runs**.
* The maximum k is the **minimum length of two neighboring runs**.
* Clean linear-time solution by **grouping streaks** instead of sliding every window.


