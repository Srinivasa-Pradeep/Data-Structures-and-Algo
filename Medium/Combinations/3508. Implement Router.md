# [Implement Router](https://leetcode.com/problems/implement-router/description/): Learning Summary

## Problem Overview
Design a `Router` class that can:
- Store packets with `(source, destination, timestamp)` attributes.
- Avoid duplicates.
- Forward packets in FIFO order.
- Count packets for a given destination in a time range.
- Respect a fixed memory limit (remove oldest packets if full).

## Core Concepts
1. **Duplicates → Set**
   - Use a set to track `(source, destination, timestamp)` for O(1) duplicate checks.

2. **Order → Queue**
   - Use a queue (`deque`) to maintain FIFO order for forwarding packets.

3. **Time-Range Counting → Sorted Timestamps**
   - Maintain a sorted list of timestamps for each destination.
   - Use **binary search** (`bisect`) to quickly count packets in `[startTime, endTime]`.

## Mental Flow for Adding a Packet
1. Check for duplicates in the set → ignore if exists.
2. If memory is full → remove the oldest packet from:
   - Queue
   - Set
   - Destination timestamp list
3. Add the new packet to:
   - Queue
   - Set
   - Sorted timestamp list

## Forwarding a Packet
- Pop the oldest from the queue.
- Remove it from the set and the destination timestamp list.
- Return `[source, destination, timestamp]`.

## Counting Packets
- Use the sorted timestamp list for the destination.
- Apply binary search (`bisect_left`, `bisect_right`) to get count in `[startTime, endTime]`.

## Optimization
- Using `SortedList` from `sortedcontainers` for timestamps:
  - `add`, `remove`, and range counting → O(log n)
  - Scales efficiently for large memory limits and many packets.

## Key Takeaways
- Queue + Set + Sorted structure = efficient, clean solution.
- Binary search is your friend for range queries.
- Ignore decorative platform-specific lines (e.g., `atexit` hacks) — they don’t affect logic.
- Building a mental model first (post office analogy) makes the problem intuitive before touching code.


