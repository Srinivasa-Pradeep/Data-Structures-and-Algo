# [Implement Router](https://leetcode.com/problems/implement-router/description/): Learning Summary

## Problem Overview
Design a `Router` class that can:
- Store packets with `(source, destination, timestamp)` attributes.
- Avoid duplicates.
- Forward packets in FIFO order.
- Count packets for a given destination in a time range.
- Respect a fixed memory limit (remove oldest packets if full).

## Core Concepts
1. **Duplicates → Set**
   - Use a set to track `(source, destination, timestamp)` for O(1) duplicate checks.

2. **Order → Queue**
   - Use a queue (`deque`) to maintain FIFO order for forwarding packets.

3. **Time-Range Counting → Sorted Timestamps**
   - Maintain a sorted list of timestamps for each destination.
   - Use **binary search** (`bisect`) to quickly count packets in `[startTime, endTime]`.

## Mental Flow for Adding a Packet
1. Check for duplicates in the set → ignore if exists.
2. If memory is full → remove the oldest packet from:
   - Queue
   - Set
   - Destination timestamp list
3. Add the new packet to:
   - Queue
   - Set
   - Sorted timestamp list

## Forwarding a Packet
- Pop the oldest from the queue.
- Remove it from the set and the destination timestamp list.
- Return `[source, destination, timestamp]`.

## Counting Packets
- Use the sorted timestamp list for the destination.
- Apply binary search (`bisect_left`, `bisect_right`) to get count in `[startTime, endTime]`.

## Python Code (Original “Magic Liner”)

```python
from collections import deque, defaultdict
import bisect

class Router:
    def __init__(self, memoryLimit: int):
        self.queue = deque()
        self.packetSet = set()
        self.destMap = defaultdict(list)
        self.memoryLimit = memoryLimit

    def addPacket(self, s, d, t):
        key = (s, d, t)
        if key in self.packetSet: return False
        if len(self.queue) >= self.memoryLimit:
            old = self.queue.popleft()
            self.packetSet.remove(old)
            ts_list = self.destMap[old[1]]
            idx = bisect.bisect_left(ts_list, old[2])
            ts_list.pop(idx)
        self.queue.append(key)
        self.packetSet.add(key)
        bisect.insort(self.destMap[d], t)
        return True

    def forwardPacket(self):
        if not self.queue: return []
        old = self.queue.popleft()
        self.packetSet.remove(old)
        ts_list = self.destMap[old[1]]
        idx = bisect.bisect_left(ts_list, old[2])
        ts_list.pop(idx)
        return list(old)

    def getCount(self, d, start, end):
        ts_list = self.destMap[d]
        return bisect.bisect_right(ts_list, end) - bisect.bisect_left(ts_list, start)

```
## Key Takeaways
- Queue + Set + Sorted structure = efficient, clean solution.
- Binary search is your friend for range queries.
- Ignore decorative platform-specific lines (e.g., `atexit` hacks) — they don’t affect logic.
- Building a mental model first (post office analogy) makes the problem intuitive before touching code.


