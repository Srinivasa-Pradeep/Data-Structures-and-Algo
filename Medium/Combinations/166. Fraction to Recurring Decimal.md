# ðŸ“˜ Notes â€“ [Fraction to Recurring Decimal](https://leetcode.com/problems/fraction-to-recurring-decimal/description/)

### **Topic**

* Math / Number Theory
* Strings
* Hashing (maps/dictionaries)

---

### **Core Idea**

* Convert `numerator/denominator` into decimal string.
* If the fractional part repeats, enclose the repeating digits in parentheses.
* Use a dictionary to detect repeating **remainders**.

---

### **Steps**

1. **Check divisibility** â†’ If `numerator % denominator == 0`, return integer.
2. **Handle sign** â†’ Negative if `numerator * denominator < 0`.
3. **Integer part** â†’ `integer_part = numerator // denominator`.
4. **Track fractional digits**:

   * Multiply remainder by 10.
   * Append quotient digit.
   * Store remainder index in map.
   * If remainder repeats â†’ repeating cycle found.
5. **Insert parentheses** around repeating part.

---

### **Quick Examples**

* `1 / 2   -> "0.5"`
* `2 / 1   -> "2"`
* `4 / 333 -> "0.(012)"`
* `-50 / 8 -> "-6.25"`
* `1 / 6   -> "0.1(6)"`

---

### **Code**

```python
class Solution:
    def fractionToDecimal(self, numerator: int, denominator: int) -> str:
        if numerator % denominator == 0:
            return str(numerator // denominator)
        
        res = '-' if numerator * denominator < 0 else ''
        numerator, denominator = abs(numerator), abs(denominator)
        res += str(numerator // denominator) + '.'
        
        remainder = numerator % denominator
        seen = {}
        decimal = ''
        
        while remainder:
            if remainder in seen:
                idx = seen[remainder]
                decimal = decimal[:idx] + '(' + decimal[idx:] + ')'
                break
            seen[remainder] = len(decimal)
            remainder *= 10
            decimal += str(remainder // denominator)
            remainder %= denominator
        
        return res + decimal

```

---

### ðŸŒŸ **Magic One-liner / Core Trick**

> Track each remainder in a hash map with its position.
> If a remainder repeats, the digits between its first occurrence and now form the repeating cycle.

---

### âœ… **Key Takeaways**

* **Remainder tracking = cycle detection.**
* **Dictionary stores first seen position â†’ lets us insert parentheses.**
* **Time complexity = O(n)** where `n` is cycle length.
* **Edge cases to handle:**

  * Negative numbers
  * Zero numerator
  * Exact division (no decimal part)


