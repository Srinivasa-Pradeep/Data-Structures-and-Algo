# ðŸ“˜ Notes â€“ [Fraction to Recurring Decimal](https://leetcode.com/problems/fraction-to-recurring-decimal/description/)

### **Topic**

* Math / Number Theory
* Strings
* Hashing (maps/dictionaries)

---

### **Core Idea**

* Convert `numerator/denominator` into decimal string.
* If the fractional part repeats, enclose the repeating digits in parentheses.
* Use a dictionary to detect repeating **remainders**.

---

### **Steps**

1. **Check divisibility** â†’ If `numerator % denominator == 0`, return integer.
2. **Handle sign** â†’ Negative if `numerator * denominator < 0`.
3. **Integer part** â†’ `integer_part = numerator // denominator`.
4. **Track fractional digits**:

   * Multiply remainder by 10.
   * Append quotient digit.
   * Store remainder index in map.
   * If remainder repeats â†’ repeating cycle found.
5. **Insert parentheses** around repeating part.

---

### **Quick Examples**

* `1 / 2   -> "0.5"`
* `2 / 1   -> "2"`
* `4 / 333 -> "0.(012)"`
* `-50 / 8 -> "-6.25"`
* `1 / 6   -> "0.1(6)"`

---

### **Code**

```python
class Solution:
    def fractionToDecimal(self, numerator: int, denominator: int) -> str:
        if numerator == 0:
            return "0"
        # handle sign
        sign = "-" if numerator * denominator < 0 else ""
        n, d = abs(numerator), abs(denominator)

        # integer part
        integer_part, rem = divmod(n, d)
        result = [sign + str(integer_part)]

        if rem == 0:
            return result[0]

        result.append(".")
        seen, frac_digits = {}, []

        while rem:
            if rem in seen:
                idx = seen[rem]
                frac_digits.insert(idx, "(")
                frac_digits.append(")")
                break
            seen[rem] = len(frac_digits)
            rem *= 10
            digit, rem = divmod(rem, d)
            frac_digits.append(str(digit))

        result.append("".join(frac_digits))
        return "".join(result)
```

---

### ðŸŒŸ **Magic One-liner / Core Trick**

> Track each remainder in a hash map with its position.
> If a remainder repeats, the digits between its first occurrence and now form the repeating cycle.

---

### âœ… **Key Takeaways**

* **Remainder tracking = cycle detection.**
* **Dictionary stores first seen position â†’ lets us insert parentheses.**
* **Time complexity = O(n)** where `n` is cycle length.
* **Edge cases to handle:**

  * Negative numbers
  * Zero numerator
  * Exact division (no decimal part)


