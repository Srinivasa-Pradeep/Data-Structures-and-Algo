# [Maximum Frequency of an Element After Performing Operations I](https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-i/description/) - Notes 

You can choose exactly `numOperations` distinct indices and for each chosen index add any integer in `[-k, k]`. Return the maximum frequency of any value after these operations.

Key observation: an element `a` can be turned into value `t` iff `t ‚àà [a - k, a + k]`. So for any target `t`, the set of indices that can be converted to `t` is the set of intervals `[a - k, a + k]` that cover `t`. Let:

* `cover(t)` = number of intervals covering `t`
* `equal(t)` = number of elements already equal to `t`

If we want value `t` to be the mode after operations:

* We can convert at most `numOperations` non-equal elements among those covered.
* So final frequency for `t` = `min( cover(t), equal(t) + numOperations )`.

Therefore compute `cover(t)` for integer `t` and take max over all integer `t`.

---

## ‚úÖ Algorithm (sweep + diff array, O(n log n))

1. For each `a` in `nums` add interval `[a-k, a+k]`.
2. Use a difference map: `diff[l] += 1`, `diff[r+1] -= 1`.
3. Also count `equal[a]` for exact matches.
4. Iterate sorted coordinates from `diff` ‚à™ `equal`:

   * maintain `curr_cover` by prefix summing `diff`.
   * for each integer coordinate `x` (these coordinates are the integer points we care about) compute:

     * if `equal[x] > 0`: candidate = `min(curr_cover, equal[x] + numOperations)`
     * else: candidate = `min(curr_cover, numOperations)`
   * track maximum candidate.

This checks all integer `t` that could possibly be best (all endpoints + points where `equal` nonzero). For segments where `equal` is zero, the best is `min(curr_cover, numOperations)` and is checked implicitly.

---

## üß© Correct Python implementation

```python
from collections import defaultdict
from typing import List

class Solution:
    def maxFrequency(self, nums: List[int], k: int, numOperations: int) -> int:
        n = len(nums)
        if n == 0:
            return 0

        diff = defaultdict(int)
        equal = defaultdict(int)
        coords = set()

        for a in nums:
            l = a - k
            r = a + k
            diff[l] += 1
            diff[r + 1] -= 1
            equal[a] += 1
            coords.add(l); coords.add(r + 1); coords.add(a)

        # iterate coordinates in order, maintain prefix sum = coverage at current integer
        ans = 0
        curr = 0
        for x in sorted(coords):
            curr += diff.get(x, 0)
            # for integer point x, curr is cover(x)
            if equal.get(x, 0) > 0:
                cand = min(curr, equal[x] + numOperations)
            else:
                cand = min(curr, numOperations)
            if cand > ans:
                ans = cand

        # edge case: if numOperations alone can convert up to numOperations elements to some t
        # but `curr` will reflect that at some integer location covering many intervals; covered above.
        return ans
```

---

## ‚úîÔ∏è Complexity

* Time: `O(n log n)` for sorting the coordinates (number of coords ~ O(n)).
* Space: `O(n)` for diff/equal/coords.

---

## ‚ú≥ Why your earlier sliding-window approach returned 3 (wrong)

That formula treated the problem like ‚Äúwe can shift numbers arbitrarily using a total budget‚Äù or used a numeric inequality derived for a different operation model. Here each element can only be moved inside its *own* interval `[a-k, a+k]`, and we must pick *distinct indices* for operations. The sliding-window sum vs `k * numOperations` inequality does not model per-element interval feasibility, so it overestimates in cases like `[1,4,5], k=1, numOperations=2` and returns 3 incorrectly.

---

If you want, I‚Äôll:

* add a tiny worked trace for `nums=[1,4,5]` showing the intervals and how the algorithm yields 2, or
* convert the solution into a version that uses coordinate compression into a dense list if you prefer arrays over dicts.

