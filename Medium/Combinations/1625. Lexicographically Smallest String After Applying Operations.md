### [Lexicographically Smallest String After Operations](https://leetcode.com/problems/lexicographically-smallest-string-after-applying-operations/description/) - Notes

**Goal:**
Find the smallest possible string (lexicographically) you can get by repeatedly applying these two operations on the string `s`:

1. Add `a` to all digits at odd indices (cyclic with `%10`).
2. Rotate the string right by `b` positions.

---

### 🧩 Key Concepts Learned

#### 1. **`add_op(s, a)`**

* Adds `a` to every odd index of `s`.
* Wraps around with modulo 10.

```python
def add_op(s, a):
    l = [int(i) for i in s]
    for i in range(len(l)):
        if i % 2 != 0:
            l[i] = (l[i] + a) % 10
    return "".join(str(x) for x in l)
```

---

#### 2. **`rotate_op(s, b)`**

* Rotates string `s` right by `b` positions.

```python
def rotate_op(s, b):
    return s[-b:] + s[:-b]
```

---

#### 3. **`visited`**

* A `set` that keeps track of already-seen strings to **prevent infinite loops**.

---

#### 4. **BFS (Breadth-First Search)**

* Uses a `queue` (`deque`) to explore all possible strings.
* Starts from `s`, and repeatedly applies both operations.
* Keeps track of the lexicographically smallest string seen.

---

### ✅ **Final Code**

```python
from collections import deque

def add_op(s, a):
    l = [int(i) for i in s]
    for i in range(len(l)):
        if i % 2 != 0:
            l[i] = (l[i] + a) % 10
    return "".join(str(x) for x in l)

def rotate_op(s, b):
    return s[-b:] + s[:-b]

def findLexSmallestString(s, a, b):
    visited = set([s])
    q = deque([s])
    smallest = s

    while q:
        curr = q.popleft()
        if curr < smallest:
            smallest = curr

        add = add_op(curr, a)
        rot = rotate_op(curr, b)

        for nxt in [add, rot]:
            if nxt not in visited:
                visited.add(nxt)
                q.append(nxt)

    return smallest
```

---

### ⏱ **Complexity Analysis**

* **Time Complexity:**
  `O(N × 10 × N)` ≈ `O(1000)` for typical constraints
  Each rotation and addition explores new states, and there are at most `N * 10` unique strings (`N` = length of `s`).

* **Space Complexity:**
  `O(N * 10)`
  For storing visited states and the BFS queue.

