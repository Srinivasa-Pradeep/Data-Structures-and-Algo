## [Maximum Number of Operations to Move Ones to the End](https://leetcode.com/problems/maximum-number-of-operations-to-move-ones-to-the-end/description/) - Notes

You have a binary string `s`.
An operation lets you:

* Pick any pattern `"10"`
* Take that `'1'` and **push it right** until:

  * it hits another `'1'`, **or**
  * it reaches the end.

This essentially **moves a 1 across a block of 0s**.

You need to return the **maximum number of times** such operations can be performed.

---

# ðŸ§  **Deep Intuition (Read slowly daâ€¦ this is the heart of it)**

Imagine the string like this:

```
111...1 000...0
â†‘ones   â†‘zeros
```

Every **`1` that is followed by a `0` contributes operations**.
But a `1` can only be moved **until the next 1 stops it**.

So what truly matters is:

* How many **0s** are on the **right side**,
* How many **1s** are on the **left side**,
* And how often a left-side `1` can â€œjump overâ€ zeros.

---

## âœ¨ Key Insight

Each `'1'` can be pushed over **all the zeros to its right**.

Meaning:

> For each â€˜1â€™, count how many zeros appear after it.
> Sum it for all ones.

That sum is exactly the **maximum operations** possible â€” because every time a `1` crosses a `0`, that counts as **one operation**.

This is the same logic behind inversion count but only for pairs `(1, 0)`.

---

# ðŸ” **Example Walkthrough**

### Example

```
s = "010010"
```

Index:   0 1 2 3 4 5
String:  0 1 0 0 1 0

Zeros to the right of each 1:

* For the 1 at index 1 â†’ zeros on right = 3 (positions 2,3,5)
* For the 1 at index 4 â†’ zeros on right = 1 (position 5)

Total operations = **3 + 1 = 4**

---

# ðŸ”¥ **Optimal Approach**

We scan from **right to left**, maintain:

* `zeros` = number of zeros seen so far
* `ans` = total operations

Whenever we see a `'1'`, we add `zeros` to `ans`.

Time: **O(n)**
Space: **O(1)**

---

# ðŸ§¾ **Python Code (Clean & Optimal)**

```python
class Solution:
    def maxOperations(self, s: str) -> int:
        zeros = 0
        ans = 0
        
        # Traverse from right to left
        for ch in reversed(s):
            if ch == '0':
                zeros += 1
            else:  # ch == '1'
                ans += zeros
        
        return ans
```

---

# ðŸŒŒ **Why This Works**

Because each operation is literally:
**A 1 jumping over a 0.**
Count all such pairs `(1,0)` where the `1` occurs before the `0`.

The greedy pushing operation simply simulates these jumps.
But counting them directly is far more efficient.

---

