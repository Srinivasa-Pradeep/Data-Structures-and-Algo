## [Successful Pairs of Spells and Potions](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/description/) - Notes

### **Problem Summary**

Given:

* Two integer arrays:
  `spells[i]` ‚Üí strength of the *i-th spell*
  `potions[j]` ‚Üí strength of the *j-th potion*
* An integer `success`

A pair **(spell, potion)** is *successful* if  **spell √ó potion ‚â• success**


Return an array `pairs` where `pairs[i]` = number of potions that form a successful pair with `spells[i]`.

---

### **Example**

**Input:**
`spells = [5,1,3]`
`potions = [1,2,3,4,5]`
`success = 7`

**Output:**
`[4,0,3]`

---

### **Optimized Approach (O((n + m) log m))**

#### **Idea**

Instead of checking every spell‚Äìpotion pair (which is O(n√óm)),
we:

1. Sort the `potions` array.
2. For each spell, find the **minimum required potion strength** to reach `success`.
3. Use **binary search** to find the first potion that meets that requirement.
4. Count how many potions are valid from there onward.

---

### **Steps**

1. **Sort** `potions`
   ‚Üí Enables binary search.
2. **For each spell:**

   * Compute `required = ceil(success / spell)`
   * Use `bisect_left(potions, required)` to find index of first valid potion.
   * Successful potions = `len(potions) - index`
3. **Store results** in list `res`.

---
here‚Äôs your full and final markdown note da ‚Äî all clean, complete, and ready to save üìò

---

---

### **üîç Understanding `bisect_left(potions, required)`**

This finds the **first index** in `potions` where `required` can be inserted
without breaking the sort order ‚Äî i.e., the first potion **‚â• required**.

* All potions **before** that index ‚Üí too weak.
* All potions **from that index onward** ‚Üí successful.

---

#### **Example**

`potions = [1, 2, 3, 4, 5]`, `required = 3`
‚Üí `bisect_left(potions, 3)` returns `2`

That means:

* potions `[1,2]` ‚Üí fail
* potions `[3,4,5]` ‚Üí succeed
  Successful count = `len(potions) - 2 = 3`

If `required = 6`,
`bisect_left(potions, 6)` ‚Üí `5` (end of array) ‚Üí `0` successes.

---

### **üß© Binary Search Trace Example**

Let‚Äôs trace one spell from the example:
`spells = [5,1,3]`, `potions = [1,2,3,4,5]`, `success = 7`

For `spell = 5`
‚Üí `required = ceil(7 / 5) = 2`

We binary search in `[1,2,3,4,5]`:

| Step | left | right | mid | potions[mid] | Comparison | Action                     |
| ---- | ---- | ----- | --- | ------------ | ---------- | -------------------------- |
| 1    | 0    | 5     | 2   | 3            | 3 ‚â• 2      | move right ‚Üí mid (right=2) |
| 2    | 0    | 2     | 1   | 2            | 2 ‚â• 2      | move right ‚Üí mid (right=1) |
| 3    | 0    | 1     | 0   | 1            | 1 < 2      | move left ‚Üí mid+1 (left=1) |

Stops when `left == right == 1`.

‚úÖ `bisect_left` returns **1**, index of potion `2`.

So, all potions from index 1 (`[2,3,4,5]`) succeed ‚Üí 4 successful pairs.

---

**Final Output:** `[4, 0, 3]`

---

### **Code**

```python
from bisect import bisect_left
import math

class Solution:
    def successfulPairs(self, spells: list[int], potions: list[int], success: int) -> list[int]:
        potions.sort()
        n = len(potions)
        res = []

        for spell in spells:
            required = math.ceil(success / spell)
            idx = bisect_left(potions, required)
            res.append(n - idx)
        
        return res
```

---

### **Complexity**

* Sorting: `O(m log m)`
* Binary search per spell: `O(n log m)`
* **Total:** `O((n + m) log m)`
* **Space:** `O(1)` (excluding output)

---

### **Core Intuition**

> For each spell, find the smallest potion strong enough to make the product reach `success`.
> Everything to its right in the sorted list automatically forms a successful pair.

---
