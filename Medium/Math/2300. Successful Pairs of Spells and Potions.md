Here’s a neat markdown note version, da — ready to save:

---

## 🧙‍♂️ Successful Pairs of Spells and Potions

### **Problem Summary**

Given:

* Two integer arrays:
  `spells[i]` → strength of the *i-th spell*
  `potions[j]` → strength of the *j-th potion*
* An integer `success`

A pair `(spell, potion)` is **successful** if:
[
spell \times potion \geq success
]

Return an array `pairs` where `pairs[i]` = number of potions that form a successful pair with `spells[i]`.

---

### **Example**

**Input:**
`spells = [5,1,3]`
`potions = [1,2,3,4,5]`
`success = 7`

**Output:**
`[4,0,3]`

---

### **Optimized Approach (O((n + m) log m))**

#### **Idea**

Instead of checking every spell–potion pair (which is O(n×m)),
we:

1. Sort the `potions` array.
2. For each spell, find the **minimum required potion strength** to reach `success`.
3. Use **binary search** to find the first potion that meets that requirement.
4. Count how many potions are valid from there onward.

---

### **Steps**

1. **Sort** `potions`
   → Enables binary search.
2. **For each spell:**

   * Compute `required = ceil(success / spell)`
   * Use `bisect_left(potions, required)` to find index of first valid potion.
   * Successful potions = `len(potions) - index`
3. **Store results** in list `res`.

---

### **Code**

```python
from bisect import bisect_left
import math

class Solution:
    def successfulPairs(self, spells: list[int], potions: list[int], success: int) -> list[int]:
        potions.sort()
        n = len(potions)
        res = []

        for spell in spells:
            required = math.ceil(success / spell)
            idx = bisect_left(potions, required)
            res.append(n - idx)
        
        return res
```

---

### **Complexity**

* Sorting: `O(m log m)`
* Binary search per spell: `O(n log m)`
* **Total:** `O((n + m) log m)`
* **Space:** `O(1)` (excluding output)

---

### **Core Intuition**

> For each spell, find the smallest potion strong enough to make the product reach `success`.
> Everything to its right in the sorted list automatically forms a successful pair.

---

want me to add a short **dry run table** for the sample `[5,1,3]` input too, so you can visualize how indices shift?

