
# **[1513. Number of Substrings With Only 1s](https://leetcode.com/problems/number-of-substrings-with-only-1s/description/) â€” Solution Blog**

## ðŸ” **Problem Summary**

You're given a binary string `s`.
Your task is to count **how many substrings consist only of `'1'`**.

Example:
`s = "0110111"` â†’ output: `9`
All substrings made of only `'1'` must be counted.

---

## â— Key Insight

Whenever you find a consecutive block of 1s, say of length **k**, the number of all-1 substrings in that block is:

[
\frac{k \cdot (k + 1)}{2}
]

Why?
Because:

* A block `"1"` â†’ 1 substring
* Block `"11"` â†’ `"1"`, `"1"`, `"11"` â†’ 3 substrings
* Block `"111"` â†’ 6 substrings
* And so onâ€¦

So all you need to do is:

1. Walk through the string.
2. Count lengths of consecutive 1s.
3. Add up `k*(k+1)/2` for each block.
4. Use modulo (10^9+7).

---

## ðŸ§  **Approach**

### **Algorithm**

1. Initialize a counter `curr = 0` and result `ans = 0`.
2. Traverse every character in `s`.
3. If it's `'1'`, increment `curr`.
4. If it's `'0'`, compute contribution of previous block and reset `curr`.
5. At the end of string, add the last block.

---

## ðŸ§ª **Time & Space Complexity**

* **Time:** O(n) â€” single scan
* **Space:** O(1)

---

## ðŸ§© **Python Solution**

```python
class Solution:
    def numSub(self, s: str) -> int:
        MOD = 10**9 + 7
        curr = 0
        ans = 0
        
        for ch in s:
            if ch == '1':
                curr += 1
            else:
                ans = (ans + curr * (curr + 1) // 2) % MOD
                curr = 0
        
        # Add last block if ends with 1
        ans = (ans + curr * (curr + 1) // 2) % MOD
        return ans
```

---

## ðŸ’Ž Final Thoughts

This problem is all about **recognizing patterns in runs of 1s**.
Once you see the formula, everything becomes smooth and elegant.

