# **Problem Statement**

An integer `x` is **numerically balanced** if for every digit `d` in `x`, that digit appears exactly `d` times.
Given an integer `n`, find the **smallest numerically balanced number strictly greater than n**.

**Example:**

* Input: `n = 1` → Output: `22`
* Input: `n = 1000` → Output: `1333`
* Input: `n = 3000` → Output: `3133`

**Constraints:** `0 <= n <= 10^6`

---

# **Our Intuition**

1. Start checking numbers just above `n`.
2. For each number, count the frequency of each digit.
3. Verify if each digit occurs exactly as many times as its value.
4. The first number that satisfies this is the answer.

**Observations:**

* Digit `0` can’t appear.
* Only digits 1–9 matter.
* Total number of numerically balanced numbers in this range is small, so a simple brute-force works.

---

# **Python Code**

```python
def is_balanced(x: int) -> bool:
    s = str(x)
    counts = {ch: s.count(ch) for ch in s}
    for ch, freq in counts.items():
        if freq != int(ch):
            return False
    return True

def next_balanced(n: int) -> int:
    x = n + 1
    while True:
        if is_balanced(x):
            return x
        x += 1

# Test examples
print(next_balanced(1))     # 22
print(next_balanced(1000))  # 1333
print(next_balanced(3000))  # 3133
```

---

# **Time Complexity (TC)**

* In the worst case, we may check numbers up to ~10⁷, but given the constraint `n <= 10^6`, it runs fast.
* Counting digits in a number with k digits → O(k).
* So overall: **O((max_answer - n) * k)**, practical for small n.

# **Space Complexity (SC)**

* Counting digits uses a dictionary with ≤10 entries → **O(1)**.
* No extra large structures needed.

---

# **Key Learnings**

1. Read problem carefully and identify the **exact rules** — here, frequency = digit value.
2. Brute-force is okay if the range is small; don’t overcomplicate.
3. Always test **edge cases and examples manually** to understand the rule.
4. Transform your brain’s thinking into **step-by-step rules**, then code it.
5. Visualization + intuition before coding saves mistakes and mental load.
