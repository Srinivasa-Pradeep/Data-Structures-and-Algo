

## **Problem Recap**

You’re given a **0-indexed integer array** `nums` consisting of positive integers.

You can perform the following operation **any number of times**:

> Choose an index `i` such that `0 ≤ i < n - 1` and replace **either** `nums[i]` or `nums[i+1]` with `gcd(nums[i], nums[i+1])`.

Your task:
Return the **minimum number of operations** required to make **all elements equal to 1**.
If it’s **impossible**, return `-1`.



### **Example**

**Input:**
`nums = [2,6,3,4]`

**Output:**
`4`

**Explanation:**

* GCD of entire array = 1 → possible.
* Smallest subarray with GCD = 1 is `[6,3]` (length 2).
* Creating the first `1` takes `1` operation.
* Then converting the rest to `1` takes `n - 1 = 3` operations.
* **Total = 4 operations.**



## **Intuition**

Each operation can only reduce numbers (never increase them) because the GCD of two numbers is always ≤ both.

So we can reason through three main cases:

1. **If the overall GCD of the array > 1**
   → We can never reach 1. Return `-1`.

2. **If there’s already at least one `1`**
   → Each non-1 can be turned into 1 in one operation.
   → Total = `n - (count of 1s)`.

3. **Otherwise**
   → We must first *create* a 1.
   → Find the shortest subarray whose GCD = 1.
   → If that subarray has length `L`:

   * Creating the first 1 costs `L - 1` operations.
   * Spreading it to the rest costs `n - 1`.
   * **Total = L + n - 2.**


## **Naive Plan**


1. **Start each subarray from its element**
   Initialize `g = nums[i]` instead of `0`, this saves one GCD computation each time.

2. **Break early when GCD hits 1**
   Once a subarray’s GCD becomes 1, extending it further is useless. Stop and record its length.

3. **Shortcut if a single 1 exists**
   If `nums[i] == 1`, that’s the shortest possible subarray. Break immediately.

4. **Combine creation and spreading costs**

   * `(min_len - 1)` → to create the first 1
   * `(n - 1)` → to spread it
     → **Final = min_len + n - 2**


```python []
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        n,num1,g = len(nums),0,0

        for x in nums:
            if x == 1:
                num1 += 1
            g = gcd(g, x)

        if num1 > 0:
            return n - num1
        if g > 1:
            return -1

        min_len = n
        for i in range(n):
            g = 0
            for j in range(i, n):
                g = gcd(g, nums[j])
                if g == 1:
                    min_len = min(min_len, j - i + 1)
                    break

        return min_len + n - 2
```


---

### **Example Trace**

`nums = [2,6,3,4]`

| i | j | Subarray | gcd | Action             |
| - | - | -------- | --- | ------------------ |
| 0 | 1 | [2,6]    | 2   | continue           |
| 0 | 2 | [2,6,3]  | 1   | found! min_len = 3 |
| 1 | 2 | [6,3]    | 3   | not 1              |
| 1 | 3 | [6,3,4]  | 1   | found shorter (3)  |
| 2 | 3 | [3,4]    | 1   | found shorter (2)  |

`min_len = 2`, so total = `2 + 4 - 2 = 4`.



### **Complexity**

* Outer loop `O(n)`
* Inner loop worst `O(n)`
* Each GCD operation `O(log A)` (small constant factor)

**Overall:** 
 > ### O(n² log A)

Works fine for `n ≤ 2000`.



## **Key Insights**

* If **any 1** exists, you can flood the array quickly.
* If **no 1s** and **gcd(all) > 1**, impossible forever.
* Else, find the **shortest window** that can produce a 1  that’s the bottleneck.



### **Takeaways**

* This problem beautifully connects **number theory (GCD)** with **array search**.
* The insight: every operation reduces the GCD but never increases it.
* Finding that first 1 unlocks the rest. Everything after is linear cleanup.

---
